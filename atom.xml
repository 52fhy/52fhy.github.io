<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞鸿影~的blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://52fhy.github.io/"/>
  <updated>2016-01-11T13:59:30.000Z</updated>
  <id>http://52fhy.github.io/</id>
  
  <author>
    <name>飞鸿影</name>
    <email>jiancaigege@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript面向对象编程（三）：非构造函数的继承 [转]</title>
    <link href="http://52fhy.github.io/2016/01/11/javascript/object-oriented_javascript_inheritance_continued_3/"/>
    <id>http://52fhy.github.io/2016/01/11/javascript/object-oriented_javascript_inheritance_continued_3/</id>
    <published>2016-01-11T13:59:27.000Z</published>
    <updated>2016-01-11T13:59:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列的第一部分介绍了”封装”，第二部分介绍了使用构造函数实现”继承”。</p>
<p>今天是最后一个部分，介绍不使用构造函数实现”继承”。</p>
<a id="more"></a>
<p>##一、什么是”非构造函数”的继承？<br>比如，现在有一个对象，叫做”中国人”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　var Chinese = &#123;</div><div class="line">　　　　nation:&apos;中国&apos;</div><div class="line">　　&#125;;</div></pre></td></tr></table></figure></p>
<p>还有一个对象，叫做”医生”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　var Doctor =&#123;</div><div class="line">　　　　career:&apos;医生&apos;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。</p>
<p>##二、object()方法<br>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　function object(o) &#123;</div><div class="line">　　　　function F() &#123;&#125;</div><div class="line">　　　　F.prototype = o;</div><div class="line">　　　　return new F();</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　var Doctor = object(Chinese);</div></pre></td></tr></table></figure></p>
<p>然后，再加上子对象本身的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　Doctor.career = &apos;医生&apos;;</div></pre></td></tr></table></figure></p>
<p>这时，子对象已经继承了父对象的属性了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(Doctor.nation); //中国</div></pre></td></tr></table></figure></p>
<p>##三、浅拷贝<br>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　function extendCopy(p) &#123;</div><div class="line">　　　　var c = &#123;&#125;;</div><div class="line">　　　　for (var i in p) &#123; </div><div class="line">　　　　　　c[i] = p[i];</div><div class="line">　　　　&#125;</div><div class="line">　　　　c.uber = p;</div><div class="line">　　　　return c;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>使用的时候，这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　var Doctor = extendCopy(Chinese);</div><div class="line">　　Doctor.career = &apos;医生&apos;;</div><div class="line">　　alert(Doctor.nation); // 中国</div></pre></td></tr></table></figure></p>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div></pre></td></tr></table></figure></p>
<p>通过extendCopy()函数，Doctor继承了Chinese。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　var Doctor = extendCopy(Chinese);</div></pre></td></tr></table></figure></p>
<p>然后，我们为Doctor的”出生地”添加一个城市：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure></p>
<p>发生了什么事？Chinese的”出生地”也被改掉了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">　　alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门</div></pre></td></tr></table></figure></p>
<p>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。</p>
<p>##四、深拷贝<br>所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　　function deepCopy(p, c) &#123;</div><div class="line">　　　　var c = c || &#123;&#125;;</div><div class="line">　　　　for (var i in p) &#123;</div><div class="line">　　　　　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">　　　　　　　　deepCopy(p[i], c[i]);</div><div class="line">　　　　　　&#125; else &#123;</div><div class="line">　　　　　　　　　c[i] = p[i];</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　　　return c;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>使用的时候这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　var Doctor = deepCopy(Chinese);</div></pre></td></tr></table></figure></p>
<p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div><div class="line">　　Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure></p>
<p>这时，父对象就不会受到影响了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">　　alert(Chinese.birthPlaces); //北京, 上海, 香港</div></pre></td></tr></table></figure></p>
<p>目前，jQuery库使用的就是这种继承方法。<br>（完）</p>
<blockquote>
<p>作者： 阮一峰<br>日期： 2010年5月24日</p>
<p>转自：<br>Javascript面向对象编程（三）：非构造函数的继承 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列的第一部分介绍了”封装”，第二部分介绍了使用构造函数实现”继承”。&lt;/p&gt;
&lt;p&gt;今天是最后一个部分，介绍不使用构造函数实现”继承”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript面向对象编程（二）：构造函数的继承 [转]</title>
    <link href="http://52fhy.github.io/2016/01/10/javascript/object-oriented_javascript_inheritance_2/"/>
    <id>http://52fhy.github.io/2016/01/10/javascript/object-oriented_javascript_inheritance_2/</id>
    <published>2016-01-10T10:57:27.000Z</published>
    <updated>2016-01-10T10:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列的第一部分，主要介绍了如何”封装”数据和方法，以及如何从原型对象生成实例。</p>
<p>今天要介绍的是，对象之间的”继承”的五种方法。</p>
<a id="more"></a>
<p>比如，现在有一个”动物”对象的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　function Animal()&#123;</div><div class="line">　　　　this.species = &quot;动物&quot;;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>还有一个”猫”对象的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>怎样才能使”猫”继承”动物”呢？</p>
<p>##一、 构造函数绑定<br>第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　Animal.apply(this, arguments);</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　&#125;</div><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　alert(cat1.species); // 动物</div></pre></td></tr></table></figure></p>
<p>##二、 prototype模式<br>第二种方法更常见，使用prototype属性。</p>
<p>如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　Cat.prototype = new Animal();</div><div class="line">　　Cat.prototype.constructor = Cat;</div><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　alert(cat1.species); // 动物</div></pre></td></tr></table></figure></p>
<p>代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　Cat.prototype = new Animal();</div></pre></td></tr></table></figure></p>
<p>它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure></p>
<p>原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(Cat.prototype.constructor == Animal); //true</div></pre></td></tr></table></figure></p>
<p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1.constructor == Cat.prototype.constructor); // true</div></pre></td></tr></table></figure></p>
<p>因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1.constructor == Animal); // true</div></pre></td></tr></table></figure></p>
<p>这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</p>
<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　o.prototype = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　o.prototype.constructor = o;</div></pre></td></tr></table></figure></p>
<p>##三、 直接继承prototype<br>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>
<p>现在，我们先将Animal对象改写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　function Animal()&#123; &#125;</div><div class="line">　　Animal.prototype.species = &quot;动物&quot;;</div></pre></td></tr></table></figure></p>
<p>然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　Cat.prototype = Animal.prototype;</div><div class="line">　　Cat.prototype.constructor = Cat;</div><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　alert(cat1.species); // 动物</div></pre></td></tr></table></figure></p>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。</p>
<p>所以，上面这一段代码其实是有问题的。请看第二行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure></p>
<p>这一句实际上把Animal.prototype对象的constructor属性也改掉了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(Animal.prototype.constructor); // Cat</div></pre></td></tr></table></figure></p>
<p>##四、 利用空对象作为中介<br>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　var F = function()&#123;&#125;;</div><div class="line">　　F.prototype = Animal.prototype;</div><div class="line">　　Cat.prototype = new F();</div><div class="line">　　Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure></p>
<p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(Animal.prototype.constructor); // Animal</div></pre></td></tr></table></figure></p>
<p>我们将上面的方法，封装成一个函数，便于使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　function extend(Child, Parent) &#123;</div><div class="line"></div><div class="line">　　　　var F = function()&#123;&#125;;</div><div class="line">　　　　F.prototype = Parent.prototype;</div><div class="line">　　　　Child.prototype = new F();</div><div class="line">　　　　Child.prototype.constructor = Child;</div><div class="line">　　　　Child.uber = Parent.prototype;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>使用的时候，方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　extend(Cat,Animal);</div><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　alert(cat1.species); // 动物</div></pre></td></tr></table></figure></p>
<p>这个extend函数，就是YUI库如何实现继承的方法。<br>另外，说明一点，函数体最后一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　Child.uber = Parent.prototype;</div></pre></td></tr></table></figure></p>
<p>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<p>##五、 拷贝继承<br>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　function Animal()&#123;&#125;</div><div class="line">　　Animal.prototype.species = &quot;动物&quot;;</div></pre></td></tr></table></figure></p>
<p>然后，再写一个函数，实现属性拷贝的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　function extend2(Child, Parent) &#123;</div><div class="line">　　　　var p = Parent.prototype;</div><div class="line">　　　　var c = Child.prototype;</div><div class="line">　　　　for (var i in p) &#123;</div><div class="line">　　　　　　c[i] = p[i];</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　c.uber = p;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。</p>
<p>使用的时候，这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　extend2(Cat, Animal);</div><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　alert(cat1.species); // 动物</div></pre></td></tr></table></figure></p>
<p>（本系列未完，请继续阅读第三部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">《非构造函数的继承》</a>。）<br>（完）</p>
<blockquote>
<p>作者： 阮一峰<br>日期： 2010年5月23日</p>
<p>转自：<br>Javascript面向对象编程（二）：构造函数的继承 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列的第一部分，主要介绍了如何”封装”数据和方法，以及如何从原型对象生成实例。&lt;/p&gt;
&lt;p&gt;今天要介绍的是，对象之间的”继承”的五种方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 面向对象编程（一）：封装 [转]</title>
    <link href="http://52fhy.github.io/2016/01/10/javascript/object-oriented_javascript_encapsulation_1/"/>
    <id>http://52fhy.github.io/2016/01/10/javascript/object-oriented_javascript_encapsulation_1/</id>
    <published>2016-01-10T10:56:06.000Z</published>
    <updated>2016-01-10T10:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习Javascript，最难的地方是什么？<br>我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。</p>
<a id="more"></a>
<p>下面就是我的学习笔记，希望对大家学习这个部分有所帮助。我主要参考了以下两本书籍：</p>
<p>《面向对象的Javascript》（Object-Oriented JavaScript）<br>《Javascript高级程序设计（第二版）》（Professional JavaScript for Web Developers, 2nd Edition)</p>
<p>它们都是非常优秀的Javascript读物，推荐阅读。</p>
<p>笔记分成三部分。今天的第一部分是讨论”封装”（Encapsulation），后面的第二部分和第三部分讨论”继承”（Inheritance）。</p>
<p>Javascript 面向对象编程（一）：封装</p>
<p>作者：阮一峰</p>
<p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p>
<p>那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p>
<p>##一、 生成对象的原始模式<br>假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　var Cat = &#123;</div><div class="line">　　　　name : &apos;&apos;,</div><div class="line">　　　　color : &apos;&apos;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　var cat1 = &#123;&#125;; // 创建一个空对象</div><div class="line">　　　　cat1.name = &quot;大毛&quot;; // 按照原型对象的属性赋值</div><div class="line">　　　　cat1.color = &quot;黄色&quot;;</div><div class="line">　　var cat2 = &#123;&#125;;</div><div class="line">　　　　cat2.name = &quot;二毛&quot;;</div><div class="line">　　　　cat2.color = &quot;黑色&quot;;</div></pre></td></tr></table></figure></p>
<p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<p>##二、 原始模式的改进<br>我们可以写一个函数，解决代码重复的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　return &#123;</div><div class="line">　　　　　　name:name,</div><div class="line">　　　　　　color:color</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>然后生成实例对象，就等于是在调用函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div></pre></td></tr></table></figure></p>
<p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<p>##三、 构造函数模式<br>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</p>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。<br>比如，猫的原型对象现在可以这样写，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　this.name=name;</div><div class="line">　　　　this.color=color;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>我们现在就可以生成实例对象了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">　　alert(cat1.name); // 大毛</div><div class="line">　　alert(cat1.color); // 黄色</div></pre></td></tr></table></figure></p>
<p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1.constructor == Cat); //true</div><div class="line">　　alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure></p>
<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1 instanceof Cat); //true</div><div class="line">　　alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure></p>
<p>##四、构造函数模式的问题<br>构造函数方法很好用，但是存在一个浪费内存的问题。</p>
<p>请看，我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　　　this.type = &quot;猫科动物&quot;;</div><div class="line">　　　　this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>还是采用同样的方法，生成实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">　　alert(cat1.type); // 猫科动物</div><div class="line">　　cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure></p>
<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1.eat == cat2.eat); //false</div></pre></td></tr></table></figure></p>
<p>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>
<p>##五、 Prototype模式<br>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　&#125;</div><div class="line">　　Cat.prototype.type = &quot;猫科动物&quot;;</div><div class="line">　　Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure></p>
<p>然后，生成实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">　　alert(cat1.type); // 猫科动物</div><div class="line">　　cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure></p>
<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1.eat == cat2.eat); //true</div></pre></td></tr></table></figure></p>
<p>##六、 Prototype模式的验证方法<br>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。</p>
<p>###6.1 isPrototypeOf()<br>这个方法用来判断，某个proptotype对象和某个实例之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class="line">　　alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure></p>
<p>###6.2 hasOwnProperty()<br>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class="line">　　alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</div></pre></td></tr></table></figure></p>
<p>###6.3 in运算符<br>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　alert(&quot;name&quot; in cat1); // true</div><div class="line">　　alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure></p>
<p>in运算符还可以用来遍历某个对象的所有属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); &#125;</div></pre></td></tr></table></figure></p>
<p>未完，请继续阅读这个系列的第二部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">《构造函数的继承》</a>和第三部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">《非构造函数的继承》</a>。<br>（完）</p>
<blockquote>
<p>作者： 阮一峰<br>日期： 2010年5月17日</p>
<p>转自：<br>Javascript 面向对象编程（一）：封装 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Javascript，最难的地方是什么？&lt;br&gt;我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript继承机制的设计思想[转]</title>
    <link href="http://52fhy.github.io/2016/01/10/javascript/designing_ideas_of_inheritance_mechanism_in_javascript/"/>
    <id>http://52fhy.github.io/2016/01/10/javascript/designing_ideas_of_inheritance_mechanism_in_javascript/</id>
    <published>2016-01-10T10:54:06.000Z</published>
    <updated>2016-01-10T10:54:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者： 阮一峰<br>日期： 2011年6月 5日</p>
</blockquote>
<p>我一直很难理解Javascript语言的继承机制。</p>
<p>它没有”子类”和”父类”的概念，也没有”类”（class）和”实例”（instance）的区分，全靠一种很奇特的”原型链”（prototype chain）模式，来实现继承。</p>
<a id="more"></a>
<p>我花了很多时间，学习这个部分，还做了很多笔记。但是都属于强行记忆，无法从根本上理解。</p>
<p>直到昨天，我读到法国程序员<a href="http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html" target="_blank" rel="external">Vjeux</a>的解释，才恍然大悟，完全明白了Javascript为什么这样设计。</p>
<p>下面，我尝试用自己的语言，来解释它的设计思想。彻底说明白prototype对象到底是怎么回事。其实根本就没那么复杂，真相非常简单。</p>
<p>##一、从古代说起<br>要理解Javascript的设计思想，必须从它的诞生说起。</p>
<p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏”用户名”要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。</p>
<p>因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。</p>
<p><img src="http://image.beekka.com/blog/201106/bg2011060503.jpg" alt="Brendan Eich"></p>
<p>1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年推出，Sun公司正在大肆造势。</p>
<p>Brendan Eich无疑受到了影响，Javascript里面所有的数据类型都是对象（object），这一点与Java非常相似。但是，他随即就遇到了一个难题，到底要不要设计”继承”机制呢？</p>
<h2 id="二、Brendan-Eich的选择"><a href="#二、Brendan-Eich的选择" class="headerlink" title="二、Brendan Eich的选择"></a>二、Brendan Eich的选择</h2><p>如果真的是一种简易的脚本语言，其实不需要有”继承”机制。但是，Javascript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了”继承”。</p>
<p>但是，他不打算引入”类”（class）的概念，因为一旦有了”类”，Javascript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。</p>
<p>他考虑到，C++和Java语言都使用new命令，生成实例。</p>
<p>C++的写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClassName *object = new ClassName(param);</div></pre></td></tr></table></figure></p>
<p>　　<br>Java的写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Foo foo = new Foo();</div></pre></td></tr></table></figure></p>
<p>因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，Javascript没有”类”，怎么来表示原型对象呢？</p>
<p>这时，他想到C++和Java使用new命令时，都会调用”类”的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。</p>
<p>举例来说，现在有一个叫做DOG的构造函数，表示狗对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　function DOG(name)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>对这个构造函数使用new，就会生成一个狗对象的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　var dogA = new DOG(&apos;大毛&apos;);</div><div class="line">　　alert(dogA.name); // 大毛</div></pre></td></tr></table></figure></p>
<p>注意构造函数中的this关键字，它就代表了新创建的实例对象。</p>
<p>##三、new运算符的缺点<br>用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。<br>比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　function DOG(name)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.species = &apos;犬科&apos;;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>然后，生成两个实例对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　var dogA = new DOG(&apos;大毛&apos;);</div><div class="line">　　var dogB = new DOG(&apos;二毛&apos;);</div></pre></td></tr></table></figure></p>
<p>这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　dogA.species = &apos;猫科&apos;;</div><div class="line">　　alert(dogB.species); // 显示&quot;犬科&quot;，不受dogA的影响</div></pre></td></tr></table></figure></p>
<p>每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。</p>
<p>##四、prototype属性的引入<br>考虑到这一点，Brendan Eich决定为构造函数设置一个prototype属性。</p>
<p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p>
<p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p>
<p>还是以DOG构造函数为例，现在用prototype属性进行改写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">　　function DOG(name)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　&#125;</div><div class="line">　　DOG.prototype = &#123; species : &apos;犬科&apos; &#125;;</div><div class="line"></div><div class="line">　　var dogA = new DOG(&apos;大毛&apos;);</div><div class="line">　　var dogB = new DOG(&apos;二毛&apos;);</div><div class="line"></div><div class="line">　　alert(dogA.species); // 犬科</div><div class="line">　　alert(dogB.species); // 犬科</div></pre></td></tr></table></figure></p>
<p>现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　DOG.prototype.species = &apos;猫科&apos;;</div><div class="line"></div><div class="line">　　alert(dogA.species); // 猫科</div><div class="line">　　alert(dogB.species); // 猫科</div></pre></td></tr></table></figure></p>
<p>##五、总结<br>由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像”继承”了prototype对象一样。</p>
<p>这就是Javascript继承机制的设计思想。不知道我说清楚了没有，继承机制的具体应用方法，可以参考我写的系列文章：</p>
<p>　　<em> <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">《Javascript面向对象编程（一）：封装》</a>
　　</em> <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">《Javascript面向对象编程（二）：构造函数的继承》</a><br>　　* <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">《Javascript面向对象编程（三）：非构造函数的继承》</a><br>（完）</p>
<blockquote>
<p>转自:<br>Javascript继承机制的设计思想 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者： 阮一峰&lt;br&gt;日期： 2011年6月 5日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一直很难理解Javascript语言的继承机制。&lt;/p&gt;
&lt;p&gt;它没有”子类”和”父类”的概念，也没有”类”（class）和”实例”（instance）的区分，全靠一种很奇特的”原型链”（prototype chain）模式，来实现继承。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript构造函数与prototype</title>
    <link href="http://52fhy.github.io/2016/01/10/javascript/Javascript_construct_and_prototype/"/>
    <id>http://52fhy.github.io/2016/01/10/javascript/Javascript_construct_and_prototype/</id>
    <published>2016-01-10T10:53:27.000Z</published>
    <updated>2016-01-10T10:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>##构造函数</p>
<ul>
<li>在Javascript语言中，new命令后面跟的不是类，而是构造函数(constructor)。</li>
</ul>
<p>构造函数理解：</p>
<blockquote>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p>
</blockquote>
<a id="more"></a>
<p>比如，猫的原型对象可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　　this.name=name;</div><div class="line">　　this.color=color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们现在就可以生成实例对象了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.name); // 大毛</div><div class="line">alert(cat1.color); // 黄色</div></pre></td></tr></table></figure></p>
<p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Cat); //true</div><div class="line">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure></p>
<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1 instanceof Cat); //true</div><div class="line">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure></p>
<p>函数与对象的构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function dog(name)&#123;</div><div class="line">　this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var dogA = new dog(&apos;大毛&apos;);</div><div class="line"></div><div class="line"></div><div class="line">&gt; dog.constructor == Function</div><div class="line">true</div><div class="line">&gt; dogA.constructor == dog</div><div class="line">true</div><div class="line"></div><div class="line"></div><div class="line">var dogB = &#123;</div><div class="line">    &apos;name&apos;:&apos;二毛&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&gt; dogB.constructor == Object</div><div class="line">true</div></pre></td></tr></table></figure></p>
<p>由上面的例子可以看出，通过new命令后面跟的不是类，而是构造函数。另外，对于使用var定义的对象，它的构造函数是对象(Object)，而不是Function,可以理解为非构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var a = new Function();</div><div class="line">&gt; a.constructor == Function</div><div class="line">true</div><div class="line"></div><div class="line">var b= &#123;&#125;;</div><div class="line">&gt; b.constructor == Object</div><div class="line">true</div><div class="line"></div><div class="line">var c= new Object();</div><div class="line">&gt; c.constructor == Object</div><div class="line">true</div><div class="line"></div><div class="line">var d = function()&#123;&#125;;</div><div class="line">&gt; d.constructor == Function</div><div class="line">true</div></pre></td></tr></table></figure>
<p>##构造函数的缺点</p>
<ul>
<li>用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</li>
</ul>
<p>我们现在为Cat对象添加一个不变的属性”type”（种类），再添加一个方法eat（吃老鼠）。那么，原型对象Cat就变成了下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　　　this.type = &quot;猫科动物&quot;;</div><div class="line">　　　　this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>还是采用同样的方法，生成实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">　　var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">　　alert(cat1.type); // 猫科动物</div><div class="line">　　cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure></p>
<p>这里有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　alert(cat1.eat == cat2.eat); //false</div></pre></td></tr></table></figure></p>
<p>##prototype的引入</p>
<ul>
<li>引入prototype(原型)属性，共享属性和方法。实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</li>
</ul>
<p>只有构造函数才有prototype属性。继续使用上面创建的对象a,b：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; a.prototype</div><div class="line">Object &#123;&#125;</div><div class="line"></div><div class="line">&gt; b.prototype</div><div class="line">undefined</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
</blockquote>
<p>我们可以把那些不变的属性和方法，直接定义在prototype对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　function Cat(name,color)&#123;</div><div class="line">　　　　this.name = name;</div><div class="line">　　　　this.color = color;</div><div class="line">　　&#125;</div><div class="line">　　Cat.prototype.type = &quot;猫科动物&quot;;//不能使用this写在构造函数里面</div><div class="line">　　Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure></p>
<p>同样实例化出cat1和cat2，我们可以发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.eat == cat2.eat); //true</div></pre></td></tr></table></figure></p>
<p>##Prototype模式的验证方法<br>1) 使用hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div></pre></td></tr></table></figure></p>
<p>2) object1.isPrototypeOf(object2) 判断object1是否存在于另一个对象object2的原型链中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alert(Cat.prototype.isPrototypeOf(cat1)); //true,cat1的原型链中包含Cat.prototype</div><div class="line"></div><div class="line">//在控制台可以打印出：</div><div class="line">&gt;Cat.prototype</div><div class="line">Cat &#123;type: &quot;猫科动物&quot;, eat: function&#125;</div><div class="line"></div><div class="line">&gt;cat1</div><div class="line">Cat &#123;name: &quot;大毛&quot;, color: &quot;黄色&quot;, type: &quot;猫科动物&quot;, eat: function&#125;</div></pre></td></tr></table></figure></p>
<p>3) in运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(&quot;name&quot; in cat1); // true</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考：</p>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="external">Javascript继承机制的设计思想</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="external">Javascript面向对象编程（一）：封装</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="external">Javascript面向对象编程（二）：构造函数的继承</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="external">Javascript面向对象编程（三）：非构造函数的继承</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##构造函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Javascript语言中，new命令后面跟的不是类，而是构造函数(constructor)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造函数理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>call,apply,bind的使用</title>
    <link href="http://52fhy.github.io/2016/01/10/javascript/javascript_call_apply_bind/"/>
    <id>http://52fhy.github.io/2016/01/10/javascript/javascript_call_apply_bind/</id>
    <published>2016-01-10T07:58:11.000Z</published>
    <updated>2016-01-10T07:58:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj.call(thisObj, arg1, arg2, ...);</div><div class="line">obj.apply(thisObj, [arg1, arg2, ...]);</div></pre></td></tr></table></figure>
<p>两者作用一致，都是把<code>obj</code>绑定到<code>thisObj</code>，这时候<code>thisObj</code>具备了<code>obj</code>的属性和方法。或者说<code>thisObj</code>继承了<code>obj</code>的属性和方法。</p>
<p>唯一区别是apply接受的是数组参数，call接受的是连续参数。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function add(j, k)&#123;</div><div class="line">	return j+k;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sub(j, k)&#123;</div><div class="line">	return j-k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在控制台运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">add(5,3); //8</div><div class="line">add.call(sub, 5, 3); //8</div><div class="line">add.apply(sub, [5, 3]); //8</div><div class="line"></div><div class="line">sub(5, 3); //2</div><div class="line">sub.call(add, 5, 3); //2</div><div class="line">sub.apply(add, [5, 3]); //2</div></pre></td></tr></table></figure></p>
<h2 id="bind的使用"><a href="#bind的使用" class="headerlink" title="bind的使用"></a>bind的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.bind(thisObj, arg1, arg2, ...);</div></pre></td></tr></table></figure>
<p>把obj绑定到thisObj，这时候thisObj具备了obj的属性和方法。与call和apply不同的是，bind绑定后不会立即执行。</p>
<p>同样是add()和sub()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add.bind(sub, 5, 3); //不再返回8</div><div class="line">add.bind(sub, 5, 3)(); //8</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;call和apply&quot;&gt;&lt;a href=&quot;#call和apply&quot; class=&quot;headerlink&quot; title=&quot;call和apply&quot;&gt;&lt;/a&gt;call和apply&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;obj.call(thisObj, arg1, arg2, ...);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;obj.apply(thisObj, [arg1, arg2, ...]);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;两者作用一致，都是把&lt;code&gt;obj&lt;/code&gt;绑定到&lt;code&gt;thisObj&lt;/code&gt;，这时候&lt;code&gt;thisObj&lt;/code&gt;具备了&lt;code&gt;obj&lt;/code&gt;的属性和方法。或者说&lt;code&gt;thisObj&lt;/code&gt;继承了&lt;code&gt;obj&lt;/code&gt;的属性和方法。&lt;/p&gt;
&lt;p&gt;唯一区别是apply接受的是数组参数，call接受的是连续参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式30分钟入门教程</title>
    <link href="http://52fhy.github.io/2015/12/30/regular_expression_tutorial_30_minutes/"/>
    <id>http://52fhy.github.io/2015/12/30/regular_expression_tutorial_30_minutes/</id>
    <published>2015-12-30T12:11:09.000Z</published>
    <updated>2015-12-30T12:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>
<h2 id="如何使用本教程"><a href="#如何使用本教程" class="headerlink" title="如何使用本教程"></a>如何使用本教程</h2><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。</p>
<a id="more"></a>
<h2 id="正则表达式到底是什么东西？"><a href="#正则表达式到底是什么东西？" class="headerlink" title="正则表达式到底是什么东西？"></a>正则表达式到底是什么东西？</h2><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<p>很可能你使用过<code>Windows/Dos</code>下用于文件查找的通配符(wildcard)，也就是<code>*</code>和<code>?</code>。如果你想查找某个目录下的所有的Word文档的话，你会搜索<code>*.doc</code>。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号”-“，最后是7或8位数字的字符串(像<code>010-12345678</code>或<code>0376-7654321</code>)。</p>
<p>注：字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。<br>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。</p>
<p>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h，后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。</p>
<p>不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\bhi\b</code>。</p>
<p><code>\b</code>是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p>
<p>注：如果需要更精确的说法，<code>\b</code>匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)<code>\w</code>。</p>
<p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用<code>\bhi\b.*\bLucy\b</code>。<br>这里<code>.</code>是另一个元字符，匹配除了换行符以外的任意字符。</p>
<p><code>*</code>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。</p>
<p>因此，<code>.*</code>连在一起就意味着任意数量的不包含换行的字符。现在<code>\bhi\b.*\bLucy\b</code>的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</p>
<p>注：换行符就是<code>&#39;\n&#39;</code>,ASCII编码为10(十六进制0x0A)的字符。</p>
<p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：</p>
<p><code>0\d\d-\d\d\d\d\d\d\d\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号”-“，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。</p>
<p>这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。</p>
<p>为了避免那么多烦人的重复，我们也可以这样写这个表达式：<code>0\d{2}-\d{8}</code>。这里<code>\d</code>后面的<code>{2}({8})</code>的意思是前面\d必须连续重复匹配2次(8次)。</p>
<h2 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h2><p>如果你不觉得正则表达式很难读写的话，要么你是一个天才，要么，你不是地球人。正则表达式的语法很令人头疼，即使对经常使用它的人来说也是如此。由于难于读写，容易出错，所以找一种工具对正则表达式进行测试是很有必要的。</p>
<p>不同的环境下正则表达式的一些细节是不相同的，这里介绍两种可用的测试工具：<br><a href="http://www.regexbuddy.com/" target="_blank" rel="external">RegexBuddy</a><br><a href="http://regexpal.com/" target="_blank" rel="external">Javascript正则表达式在线测试工具</a></p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如<code>\b,.,*</code>，还有<code>\d.</code>正则表达式里还有更多的元字符，比如<code>\s</code>匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。<code>\w</code>匹配字母或数字或下划线或汉字等。</p>
<p>注：对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。</p>
<p>下面来看看更多的例子：</p>
<p><code>\ba\w*\b</code>匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。</p>
<p>注：好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)</p>
<p><code>\d+</code>匹配1个或更多连续的数字。这里的+是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</p>
<p><code>\b\w{6}\b</code> 匹配刚好6个字符的单词。</p>
<p>表1.常用的元字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">代码	说明</div><div class="line">.	匹配除换行符以外的任意字符</div><div class="line">\w	匹配字母或数字或下划线或汉字</div><div class="line">\s	匹配任意的空白符</div><div class="line">\d	匹配数字</div><div class="line">\b	匹配单词的开始或结束</div><div class="line">^	匹配字符串的开始</div><div class="line">$	匹配字符串的结束</div></pre></td></tr></table></figure></p>
<p>注：正则表达式引擎通常会提供一个”测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的<code>RegExp.test()</code>方法或.NET里的<code>Regex.IsMatch()</code>方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于<code>\d{5,12}</code>而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。</p>
<p>元字符<code>^</code>（和数字6在同一个键位上的符号）和<code>$</code>都匹配一个位置，这和\b有点类似。<code>^</code>匹配你要用来查找的字符串的开头，<code>$</code>匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<code>^\d{5,12}$</code>。</p>
<p>这里的<code>{5,12}</code>和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，<code>{5,12}</code>则是重复的次数不能少于5次，不能多于12次，否则都不匹配。</p>
<p>因为使用了<code>^</code>和<code>$</code>，所以输入的整个字符串都要用来和<code>\d{5,12}</code>来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。</p>
<p>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找<code>.</code>或者<code>*</code>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和*。当然，要查找\本身，你也得用\.</p>
<p>例如：<code>deerchao\.net</code>匹配deerchao.net，<code>C:\\Windows</code>匹配C:\Windows。</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>你已经看过了前面的<code>*,+,{2},{5,12}</code>这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如<code>*,{5,12}</code>等)：</p>
<p>表2.常用的限定符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">代码/语法	说明</div><div class="line"></div><div class="line">*	重复零次或更多次</div><div class="line">+	重复一次或更多次</div><div class="line">?	重复零次或一次</div><div class="line">&#123;n&#125;	重复n次</div><div class="line">&#123;n,&#125;	重复n次或更多次</div><div class="line">&#123;n,m&#125;	重复n到m次</div></pre></td></tr></table></figure></p>
<p>下面是一些使用重复的例子：<br><code>Windows\d+</code>匹配Windows后面跟1个或更多数字<br><code>^\w+</code>匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p>
<p>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号(.或?或!)。<br>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理<code>[a-z0-9A-Z_]</code>也完全等同于\w（如果只考虑英文的话）。</p>
<p>下面是一个更复杂的表达式：<code>\(?0\d{2}[) -]?\d{8}</code>。<br>注意：<code>(</code>和<code>)</code>也是元字符，后面的分组节里会提到，所以在这里需要使用转义。</p>
<p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符<code>\(</code>,它能出现0次或1次<code>(?)</code>,然后是一个0，后面跟着2个数字<code>(\d{2})</code>，然后是<code>)</code>或<code>-</code>或空格中的一个，它出现1次或不出现<code>(?)</code>，最后是8个数字<code>(\d{8})</code>。</p>
<h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的”不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：</p>
<p><code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。</p>
<p><code>\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}</code>这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</p>
<p><code>\d{5}-\d{4}|\d{5}</code>这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成<code>\d{5}|\d{5}-\d{4}</code>的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p>
<p><code>(\d{1,3}\.){3}\d{1,3}</code>是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：<code>\d{1,3}</code>匹配1到3位的数字，<code>(\d{1,3}\.){3}</code>匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字<code>(\d{1,3})</code>。</p>
<p>注：IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>
<p>不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</code>。</p>
<p>理解这个表达式的关键是理解<code>2[0-4]\d|25[0-5]|[01]?\d\d?</code>，这里我就不细说了，你自己应该能分析得出来它的意义。</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>
<p>表3.常用的反义代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">代码/语法	说明</div><div class="line"></div><div class="line">\W	匹配任意不是字母，数字，下划线，汉字的字符</div><div class="line">\S	匹配任意不是空白符的字符</div><div class="line">\D	匹配任意非数字的字符</div><div class="line">\B	匹配不是单词开头或结束的位置</div><div class="line">[^x]	匹配除了x以外的任意字符</div><div class="line">[^aeiou]	匹配除了aeiou这几个字母以外的任意字符</div></pre></td></tr></table></figure></p>
<p>例子：<code>\S+</code>匹配不包含空白符的字符串。<br><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以a开头的字符串。</p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>呃……其实，组号分配还不像我刚说得那么简单：</p>
<p>分组0对应整个正则表达式。</p>
<p>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号<br>你可以使用<code>(?:exp)</code>这样的语法来剥夺一个分组对组号分配的参与权<br>后向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。难以理解？请看示例：</p>
<p><code>\b(\w+)\b\s+\1\b</code>可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字<code>(\b(\w+)\b)</code>，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符<code>(\s+)</code>，最后是分组1中捕获的内容（也就是前面匹配的那个单词）<code>(\1)</code>。</p>
<p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：<code>(?&lt;Word&gt;\w+)</code>(或者把尖括号换成’也行：<code>(?&#39;Word&#39;\w+)</code>),这样就把<code>\w+</code>的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用<code>\k&lt;Word&gt;</code>,所以上一个例子也可以写成这样：<code>\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b</code>。</p>
<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p>
<p>表4.常用分组语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">分类	代码/语法	说明</div><div class="line"></div><div class="line">捕获	(exp)	匹配exp,并捕获文本到自动命名的组里</div><div class="line">(?&lt;name&gt;exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?&apos;name&apos;exp)</div><div class="line">(?:exp)	匹配exp,不捕获匹配的文本，也不给此分组分配组号</div><div class="line">零宽断言	(?=exp)	匹配exp前面的位置</div><div class="line">(?&lt;=exp)	匹配exp后面的位置</div><div class="line">(?!exp)	匹配后面跟的不是exp的位置</div><div class="line">(?&lt;!exp)	匹配前面不是exp的位置</div><div class="line">注释	(?#comment)这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</div></pre></td></tr></table></figure></p>
<p>我们已经讨论了前两种语法。第三个<code>(?:exp)</code>不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。”我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像<code>\b,^,$</code>那样用于指定一个位置，这个位置应该满足一定的条件（即断言），因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p>
<p>注：断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p>
<p><code>(?=exp)</code>也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如<code>\b\w+(?=ing\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p>
<p><code>(?&lt;=exp)</code>也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如<code>(?&lt;=\bre)\w+\b</code>会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p>
<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：`((?&lt;=\d)\d{3})+\b``，用它对1234567890进行查找时结果是234567890。</p>
<p>下面这个例子同时使用了这两种断言：<code>(?&lt;=\s)\d+(?=\s)</code>匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</p>
<p><code>\b\w*q[^u]\w*\b</code>匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为<code>[^u]</code>总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的<code>[^u]</code>将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的<code>\w*\b</code>将会匹配下一个单词，于是<code>\b\w*q[^u]\w*\b</code>就能匹配整个<code>Iraq fighting</code>。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：<code>\b\w*q(?!u)\w*\b</code>。</p>
<p>零宽度负预测先行断言<code>(?!exp)</code>，断言此位置的后面不能匹配表达式exp。例如：<code>\d{3}(?!\d)</code>匹配三位数字，而且这三位数字的后面不能是数字；<code>\b((?!abc)\w)+\b</code>匹配不包含连续字符串abc的单词。</p>
<p>同理，我们可以用<code>(?&lt;!exp)</code>,零宽度负回顾后发断言来断言此位置的前面不能匹配表达式<code>exp：(?&lt;![a-z])\d{7}</code>匹配前面不是小写字母的七位数字。</p>
<p>一个更复杂的例子：<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>匹配不包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词(比如可能是<code>&lt;b&gt;</code>)，然后是.*(任意的字符串),最后是一个后缀<code>(?=&lt;\/\1&gt;)</code>。注意后缀里的<code>\/</code>，它用到了前面提过的字符转义；<code>\1</code>则是一个反向引用，引用的正是捕获的第一组，前面的<code>(\w+)</code>匹配的内容，这样如果前缀实际上是<code>&lt;b&gt;</code>的话，后缀就是<code>&lt;/b&gt;</code>了。整个表达式匹配的是<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>
<p>注：请详细分析表达式<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>，这个表达式最能表现零宽断言的真正用途。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>小括号的另一种用途是通过语法<code>(?#comment)</code>来包含注释。例如：<code>2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</code>。<br>要包含注释的话，最好是启用”忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(?&lt;=    # 断言要匹配的文本的前缀</div><div class="line">&lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)</div><div class="line">)       # 前缀结束</div><div class="line">.*      # 匹配任意文本</div><div class="line">(?=     # 断言要匹配的文本的后缀</div><div class="line">&lt;\/\1&gt;  # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签</div><div class="line">)       # 后缀结束</div></pre></td></tr></table></figure></p>
<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</p>
<p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p>
<p><code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。<br>注：为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p>
<p>表5.懒惰限定符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">代码/语法	说明</div><div class="line"></div><div class="line">*?	重复任意次，但尽可能少重复</div><div class="line">+?	重复1次或更多次，但尽可能少重复</div><div class="line">??	重复0次或1次，但尽可能少重复</div><div class="line">&#123;n,m&#125;?	重复n到m次，但尽可能少重复</div><div class="line">&#123;n,&#125;?	重复n次以上，但尽可能少重复</div></pre></td></tr></table></figure></p>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：</p>
<p>表6.常用的处理选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">名称	说明</div><div class="line">IgnoreCase(忽略大小写)	匹配时不区分大小写。</div><div class="line"></div><div class="line">Multiline(多行模式)	更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</div><div class="line"></div><div class="line">Singleline(单行模式)	更改.的含义，使它与每一个字符匹配（包括换行符\n）。</div><div class="line"></div><div class="line">IgnorePatternWhitespace(忽略空白)	忽略表达式中的非转义空白并启用由#标记的注释。</div><div class="line"></div><div class="line">ExplicitCapture(显式捕获)	仅捕获已被显式命名的组。</div></pre></td></tr></table></figure></p>
<p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。</p>
<p>注：在C#中，你可以使用<code>Regex(String, RegexOptions)</code>构造函数来设置正则表达式的处理选项。如：<code>Regex regex = new Regex(@&quot;\ba\w{6}\b&quot;, RegexOptions.IgnoreCase)</code>;</p>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><blockquote>
<p>注：这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。</p>
</blockquote>
<p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？</p>
<p>为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把<code>xx &lt;aa &lt;bbb&gt; &lt;bbb&gt; aa&gt; yy</code>这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p>
<p>这里需要用到以下的语法构造：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(?&apos;group&apos;) 把捕获的内容命名为group,并压入堆栈(Stack)</div><div class="line">(?&apos;-group&apos;) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</div><div class="line">(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</div><div class="line">(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</div></pre></td></tr></table></figure></p>
<p>注：如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个”group”，第二个就是从黑板上擦掉一个”group”，第三个就是看黑板上写的还有没有”group”，如果有就继续匹配yes部分，否则就匹配no部分。</p>
<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;                         #最外层的左括号</div><div class="line">    [^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容</div><div class="line">    (</div><div class="line">        (</div><div class="line">            (?&apos;Open&apos;&lt;)    #碰到了左括号，在黑板上写一个&quot;Open&quot;</div><div class="line">            [^&lt;&gt;]*        #匹配左括号后面的不是括号的内容</div><div class="line">        )+</div><div class="line">        (</div><div class="line">            (?&apos;-Open&apos;&gt;)   #碰到了右括号，擦掉一个&quot;Open&quot;</div><div class="line">            [^&lt;&gt;]*        #匹配右括号后面不是括号的内容</div><div class="line">        )+</div><div class="line">    )*</div><div class="line">    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&quot;Open&quot;；如果还有，则匹配失败</div><div class="line"></div><div class="line">&gt;                         #最外层的右括号</div></pre></td></tr></table></figure>
<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<code>&lt;div&gt;标签</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?&apos;Open&apos;&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?&apos;-Open&apos;&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;.</div></pre></td></tr></table></figure></p>
<h2 id="还有些什么东西没提到"><a href="#还有些什么东西没提到" class="headerlink" title="还有些什么东西没提到"></a>还有些什么东西没提到</h2><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。</p>
<p>表7.尚未详细讨论的语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">代码/语法	说明</div><div class="line"></div><div class="line">\a	报警字符(打印它的效果是电脑嘀一声)</div><div class="line">\b	通常是单词分界位置，但如果在字符类里使用代表退格</div><div class="line">\t	制表符，Tab</div><div class="line">\r	回车</div><div class="line">\v	竖向制表符</div><div class="line">\f	换页符</div><div class="line">\n	换行符</div><div class="line">\e	Escape</div><div class="line">\0nn	ASCII代码中八进制代码为nn的字符</div><div class="line">\xnn	ASCII代码中十六进制代码为nn的字符</div><div class="line">\unnnn	Unicode代码中十六进制代码为nnnn的字符</div><div class="line">\cN	ASCII控制字符。比如\cC代表Ctrl+C</div><div class="line">\A	字符串开头(类似^，但不受处理多行选项的影响)</div><div class="line">\Z	字符串结尾或行尾(不受处理多行选项的影响)</div><div class="line">\z	字符串结尾(类似$，但不受处理多行选项的影响)</div><div class="line">\G	当前搜索的开头</div><div class="line">\p&#123;name&#125;	Unicode中命名为name的字符类，例如\p&#123;IsGreek&#125;</div><div class="line">(?&gt;exp)	贪婪子表达式</div><div class="line">(?&lt;x&gt;-&lt;y&gt;exp)	平衡组</div><div class="line">(?im-nsx:exp)	在子表达式exp中改变处理选项</div><div class="line">(?im-nsx)	为表达式后面的部分改变处理选项</div><div class="line">(?(exp)yes|no)	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</div><div class="line">(?(exp)yes)	同上，只是使用空表达式作为no</div><div class="line">(?(name)yes|no)	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</div><div class="line">(?(name)yes)	同上，只是使用空表达式作为no</div></pre></td></tr></table></figure></p>
<p>更多教程</p>
<blockquote>
<p>更详细教程可参考：正则表达式-教程<br>来源：<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">http://deerchao.net/tutorials/regex/regex.htm</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;本文目标&quot;&gt;&lt;a href=&quot;#本文目标&quot; class=&quot;headerlink&quot; title=&quot;本文目标&quot;&gt;&lt;/a&gt;本文目标&lt;/h2&gt;&lt;p&gt;30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。&lt;/p&gt;
&lt;h2 id=&quot;如何使用本教程&quot;&gt;&lt;a href=&quot;#如何使用本教程&quot; class=&quot;headerlink&quot; title=&quot;如何使用本教程&quot;&gt;&lt;/a&gt;如何使用本教程&lt;/h2&gt;&lt;p&gt;别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="正则" scheme="http://52fhy.github.io/categories/%E6%AD%A3%E5%88%99/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始GTD——GTD原则</title>
    <link href="http://52fhy.github.io/2015/09/12/essay/GTDprinciple/"/>
    <id>http://52fhy.github.io/2015/09/12/essay/GTDprinciple/</id>
    <published>2015-09-12T01:57:31.000Z</published>
    <updated>2015-09-12T01:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将介绍GTD的核心原则。</p>
<h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><p>把任何你需要跟踪、记住、或者要做的事情全部记录到“收集箱”中：一个收件箱，电子邮箱，磁带，笔记本，PDA等等。把你脑中所有东西都清理出来，放入你的收集设备中，准备进行下一步的处理。每天抽几十分钟收集一下脑中的信息，记录到你的收集设备中。</p>
<a id="more"></a>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>将你收集到的任何信息进行处理。每个星期至少处理清空一次你的“收集箱”。</p>
<p>处理你的收集箱要遵循的工作流程：</p>
<ul>
<li>从第一条信息开始处理；</li>
<li>每次只处理一条信息；</li>
<li>不把任何信息放回收集箱；</li>
<li>如果任何一项需要做：</li>
</ul>
<ol>
<li>马上执行（如果花的时间少于两分钟）</li>
<li>委托别人完成，或者</li>
<li>将它延期</li>
</ol>
<ul>
<li>否则：</li>
</ul>
<ol>
<li>将它存档以便查询</li>
<li>把它删除，或者</li>
<li>为它定义合适的目标与情境，以便下一步执行</li>
</ol>
<blockquote>
<p>两分钟原则：任何事情如果花的时间少于两分钟，那么马上就去执行。两分钟是一个分水岭，这样的时间和正式地推迟一个动作所花的时间差不多。</p>
</blockquote>
<h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><p>GTD描述了一个建议的列表集合，你可以用来跟踪需要关注的项目:</p>
<ul>
<li><p><strong>下一步行动（Next actions）</strong>：对于每个需要你关注的事项，定好什么是你可以实际采取的下一步行动。例如：如果“写项目报告”，下一步行动可能会是“给Fred发邮件开个简短会议”，“给Jim打电话问报告的要求”，或者类似的事情。虽然要完成这个事项，可能会有很多的步骤和行动，但是其中一定会有你需要首先去做的事情，这样的事情就应该被记录在“下一步行动”列表上。较好的做法是把这些事项根据能够被完成的“情境”整理分类，例如“在办公室”，“用电话”，“在商场”。</p>
</li>
<li><p><strong>项目（Projects）</strong>：每个需要多于一个实际的行动才能达到目的的事就是一个“项目”。使用跟踪以及周期性的回顾来确保每个项目都有一个下一步的行动进行下去。</p>
</li>
<li><p><strong>等待（Waiting for）</strong>：当你已经指派了一个事项给其他人或者在项目进行下去之前需要等待外部的事件。就应当在你的系统当中跟踪以及定期检查是否已经可以采取行动或者一个提醒需要发出。</p>
</li>
<li><p><strong>将来/可能（Someday/Maybe）</strong>：这些事情你需要在某个点去做，但是不是马上。例如：“学习C语言”，或者“准备一个假期计划”。</p>
</li>
</ul>
<p>Allen主张使用下一步行动列表而非日历来记录行动，虽然日历非主要的工具，但是可以用来跟踪预约和委托，提醒某件必须在特定期限内完成的事情等等。</p>
<p>GTD中另外一个关键组织模块是<strong>归档系统</strong>，一个简单易用的归档系统。通过归档系统，你可以迅速把文件归档和提取你所想要的信息，Allen的建议是建立一个按照字母顺序组织的归档系统或43Folders系统（按照12月、31天，共43个文件夹）。</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>如果你把自己的时间都花在组织工作、而不是执行它们，那么这样的系统是个只说不做的无用功系统。前面的步骤都是为了在你做事情的时候，使它变得简单、容易、有趣的话，让你比较不会拖延、或者被太多的琐事所分心。</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>按时回顾自己的列表。如果你没有及时整理和回顾每天的信息和行动，那么整个GTD系统就是毫无用处的。通过回顾，指定计划，或者了解项目进度，从而使自己总是走在时间的前面，而不是被动地被安排。</p>
<p>回顾至少以星期为周期，将未处理的信息进行处理，回顾所有的列表，检查可能已经完成的“等待”或“将来/可能”列表中的行动。保证所有的事情都在GTD系统中，井井有条，而且所有的事情都更新到最新的情况。虽然刚开始GTD时，回顾很麻烦，但是千万不要停顿。否则事情的积累，只会让你的整个GTD系统处理过程堵塞，最后使你失败放弃。</p>
<blockquote>
<p>转自：<br><a href="http://www.mifengtd.cn/articles/starting-gtd-2-ruleshtml.html" target="_blank" rel="external">http://www.mifengtd.cn/articles/starting-gtd-2-ruleshtml.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将介绍GTD的核心原则。&lt;/p&gt;
&lt;h2 id=&quot;收集&quot;&gt;&lt;a href=&quot;#收集&quot; class=&quot;headerlink&quot; title=&quot;收集&quot;&gt;&lt;/a&gt;收集&lt;/h2&gt;&lt;p&gt;把任何你需要跟踪、记住、或者要做的事情全部记录到“收集箱”中：一个收件箱，电子邮箱，磁带，笔记本，PDA等等。把你脑中所有东西都清理出来，放入你的收集设备中，准备进行下一步的处理。每天抽几十分钟收集一下脑中的信息，记录到你的收集设备中。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://52fhy.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://52fhy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="时间管理" scheme="http://52fhy.github.io/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Time33算法</title>
    <link href="http://52fhy.github.io/2015/08/23/time33/"/>
    <id>http://52fhy.github.io/2015/08/23/time33/</id>
    <published>2015-08-23T03:49:00.000Z</published>
    <updated>2015-08-23T03:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Time33是字符串哈希函数，现在几乎所有流行的HashMap都采用了DJB Hash Function，俗称“Times33”算法。Times33的算法很简单，就是不断的乘33。</p>
<a id="more"></a>
<p>c语言版本<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">time33</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">char</span> str[<span class="number">3</span>] = <span class="string">"c语言"</span>;</div><div class="line">   <span class="keyword">int</span> res;</div><div class="line">	</div><div class="line">	res = time33(str);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* time33算法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">time33</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</div><div class="line">	<span class="keyword">while</span>(*str)&#123;</div><div class="line">		hash += (hash &lt;&lt; <span class="number">5</span> ) + (*str++);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JAVA版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public String time33(String skey) &#123;</div><div class="line">        if (skey == null) return null;</div><div class="line">        int hash = 5381;</div><div class="line">        for (int i = 0, len = skey.length(); i &lt; len; ++i) &#123;</div><div class="line">            int cc = skey.charAt(i);</div><div class="line">            hash += (hash &lt;&lt; 5) + cc;</div><div class="line">        &#125;</div><div class="line">        hash &amp;= 0x7fffffff;</div><div class="line">        return String.valueOf(hash);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Javascript版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//哈希time33算法</div><div class="line">function time33(str)&#123;</div><div class="line">    for(var i = 0, len = str.length,hash = 5381; i &lt; len; ++i)&#123;</div><div class="line">       hash += (hash &lt;&lt; 5) + str.charAt(i).charCodeAt();</div><div class="line">    &#125;;</div><div class="line">    return hash &amp; 0x7fffffff;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>PHP版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">function myHash($str) &#123;</div><div class="line">    // hash(i) = hash(i-1) * 33 + str[i]</div><div class="line">    $hash = 5381;</div><div class="line">    $s    = md5($str); //相比其它版本，进行了md5加密</div><div class="line">    $seed = 5;</div><div class="line">    $len  = 32;//加密后长度32</div><div class="line">    for ($i = 0; $i &lt; $len; $i++) &#123;</div><div class="line">        // (hash &lt;&lt; 5) + hash 相当于 hash * 33</div><div class="line">        //$hash = sprintf(&quot;%u&quot;, $hash * 33) + ord($s&#123;$i&#125;);</div><div class="line">        //$hash = ($hash * 33 + ord($s&#123;$i&#125;)) &amp; 0x7FFFFFFF;</div><div class="line">        $hash = ($hash &lt;&lt; $seed) + $hash + ord($s&#123;$i&#125;);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    return $hash &amp; 0x7FFFFFFF;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么初始值是5381？<br>5381（001 010 100 000 101），据说hash后的分布更好一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Magic Constant 5381:</div><div class="line">1. odd number</div><div class="line">2. prime number</div><div class="line">3. deficient number</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考<br>CSRF防御 - 为程序员服务 <a href="http://ju.outofmemory.cn/entry/75798" target="_blank" rel="external">http://ju.outofmemory.cn/entry/75798</a><br>PHP: 深入了解一致性哈希 - 陈一回的个人页面 - 开源中国社区<br><a href="http://my.oschina.net/goal/blog/203593?p=1" target="_blank" rel="external">http://my.oschina.net/goal/blog/203593?p=1</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Time33是字符串哈希函数，现在几乎所有流行的HashMap都采用了DJB Hash Function，俗称“Times33”算法。Times33的算法很简单，就是不断的乘33。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://52fhy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Javascript模块化编程（三）：require.js的用法</title>
    <link href="http://52fhy.github.io/2015/07/13/javascript/Modular_programming_Javascript_3-requirejs_usage/"/>
    <id>http://52fhy.github.io/2015/07/13/javascript/Modular_programming_Javascript_3-requirejs_usage/</id>
    <published>2015-07-13T10:22:12.000Z</published>
    <updated>2015-07-14T13:10:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列的第一部分和第二部分，介绍了Javascript模块原型和理论概念，今天介绍如何将它们用于实战。</p>
<p>我采用的是一个非常流行的库<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>。</p>
<a id="more"></a>
<h2 id="一、为什么要用require-js？"><a href="#一、为什么要用require-js？" class="headerlink" title="一、为什么要用require.js？"></a>一、为什么要用require.js？</h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　&lt;script src=<span class="string">"1.js"</span>&gt;&lt;/script&gt;</div><div class="line">　　&lt;script src=<span class="string">"2.js"</span>&gt;&lt;/script&gt;</div><div class="line">　　&lt;script src=<span class="string">"3.js"</span>&gt;&lt;/script&gt;</div><div class="line">　　&lt;script src=<span class="string">"4.js"</span>&gt;&lt;/script&gt;</div><div class="line">　　&lt;script src=<span class="string">"5.js"</span>&gt;&lt;/script&gt;</div><div class="line">　　&lt;script src=<span class="string">"6.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>这段代码依次加载多个js文件。</p>
<p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p>
<p>require.js的诞生，就是为了解决这两个问题：
　　</p>
<blockquote>
<p>（1）实现js文件的异步加载，避免网页失去响应；<br>（2）管理模块之间的依赖性，便于代码的编写和维护。</p>
</blockquote>
<h2 id="二、require-js的加载"><a href="#二、require-js的加载" class="headerlink" title="二、require.js的加载"></a>二、require.js的加载</h2><p>使用require.js的第一步，是先去官方网站下载最新版本。</p>
<p>下载后，假定把它放在js子目录下面，就可以加载了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><code>async</code>属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持<code>defer</code>，所以把defer也写上。<br>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是<code>main.js</code>，也放在js目录下面。那么，只需要写成下面这样就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><code>data-main</code>属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成<code>main</code>。</p>
<h2 id="三、主模块的写法"><a href="#三、主模块的写法" class="headerlink" title="三、主模块的写法"></a>三、主模块的写法</h2><p>上一节的<code>main.js</code>，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。</p>
<p>下面就来看，怎么写main.js。</p>
<p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　// main.js</div><div class="line">　　alert(&quot;加载成功！&quot;);</div></pre></td></tr></table></figure></p>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　// main.js</div><div class="line">　　require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123;</div><div class="line">　　　　// some code here</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p><code>require()</code>函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是<code>[&#39;moduleA&#39;, &#39;moduleB&#39;, &#39;moduleC&#39;]</code>，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p>
<p><code>require()</code>异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<p>下面，我们看一个实际的例子。</p>
<p>假定主模块依赖<code>jquery</code>、<code>underscore</code>和<code>backbone</code>这三个模块，main.js就可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123;</div><div class="line">　　　　// some code here</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<h2 id="四、模块的加载"><a href="#四、模块的加载" class="headerlink" title="四、模块的加载"></a>四、模块的加载</h2><p>上一节最后的示例中，主模块的依赖模块是<code>[&#39;jquery&#39;, &#39;underscore&#39;, &#39;backbone&#39;]</code>。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。</p>
<p>使用<code>require.config()</code>方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　require.config(&#123;</div><div class="line">　　　　paths: &#123;</div><div class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</div><div class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</div><div class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">　　require.config(&#123;</div><div class="line">　　　　paths: &#123;</div><div class="line">　　　　　　&quot;jquery&quot;: &quot;lib/jquery.min&quot;,</div><div class="line">　　　　　　&quot;underscore&quot;: &quot;lib/underscore.min&quot;,</div><div class="line">　　　　　　&quot;backbone&quot;: &quot;lib/backbone.min&quot;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>另一种则是直接改变基目录（baseUrl）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　require.config(&#123;</div><div class="line">　　　　baseUrl: &quot;js/lib&quot;,</div><div class="line">　　　　paths: &#123;</div><div class="line">　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,</div><div class="line">　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,</div><div class="line">　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　　require.config(&#123;</div><div class="line">　　　　paths: &#123;</div><div class="line">　　　　　　&quot;jquery&quot;: &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个<a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="external">优化工具</a>，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h2 id="五、AMD模块的写法"><a href="#五、AMD模块的写法" class="headerlink" title="五、AMD模块的写法"></a>五、AMD模块的写法</h2><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p>
<p>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p>
<p>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">　　// math.js</div><div class="line">　　define(function ()&#123;</div><div class="line">　　　　var add = function (x,y)&#123;</div><div class="line">　　　　　　return x+y;</div><div class="line">　　　　&#125;;</div><div class="line">　　　　return &#123;</div><div class="line">　　　　　　add: add</div><div class="line">　　　　&#125;;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>加载方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　// main.js</div><div class="line">　　require([&apos;math&apos;], function (math)&#123;</div><div class="line">　　　　alert(math.add(1,1));</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　　define([&apos;myLib&apos;], function(myLib)&#123;</div><div class="line">　　　　function foo()&#123;</div><div class="line">　　　　　　myLib.doSomething();</div><div class="line">　　　　&#125;</div><div class="line">　　　　return &#123;</div><div class="line">　　　　　　foo : foo</div><div class="line">　　　　&#125;;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<h2 id="六、加载非规范的模块"><a href="#六、加载非规范的模块" class="headerlink" title="六、加载非规范的模块"></a>六、加载非规范的模块</h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p>
<p>回答是可以的。</p>
<p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p>
<p>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　　require.config(&#123;</div><div class="line">　　　　shim: &#123;</div><div class="line"></div><div class="line">　　　　　　&apos;underscore&apos;:&#123;</div><div class="line">　　　　　　　　exports: &apos;_&apos;</div><div class="line">　　　　　　&#125;,</div><div class="line">　　　　　　&apos;backbone&apos;: &#123;</div><div class="line">　　　　　　　　deps: [&apos;underscore&apos;, &apos;jquery&apos;],</div><div class="line">　　　　　　　　exports: &apos;Backbone&apos;</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</p>
<p>比如，jQuery的插件可以这样定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　shim: &#123;</div><div class="line">　　　　&apos;jquery.scroll&apos;: &#123;</div><div class="line">　　　　　　deps: [&apos;jquery&apos;],</div><div class="line">　　　　　　exports: &apos;jQuery.fn.scroll&apos;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<h2 id="七、require-js插件"><a href="#七、require-js插件" class="headerlink" title="七、require.js插件"></a>七、require.js插件</h2><p>require.js还提供一系列插件，实现一些特定的功能。</p>
<p>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　require([&apos;domready!&apos;], function (doc)&#123;</div><div class="line">　　　　// called once the DOM is ready</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>text和image插件，则是允许require.js加载文本和图片文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">　　define([</div><div class="line">　　　　&apos;text!review.txt&apos;,</div><div class="line">　　　　&apos;image!cat.jpg&apos;</div><div class="line">　　　　],</div><div class="line"></div><div class="line">　　　　function(review,cat)&#123;</div><div class="line">　　　　　　console.log(review);</div><div class="line">　　　　　　document.body.appendChild(cat);</div><div class="line">　　　　&#125;</div><div class="line">　　);</div></pre></td></tr></table></figure></p>
<p>类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>
<blockquote>
<p>作者： 阮一峰<br>日期： 2012年11月7日<br>来源： <a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/11/require_js.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列的第一部分和第二部分，介绍了Javascript模块原型和理论概念，今天介绍如何将它们用于实战。&lt;/p&gt;
&lt;p&gt;我采用的是一个非常流行的库&lt;a href=&quot;http://requirejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;require.js&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://52fhy.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Javascript模块化编程（二）：AMD规范</title>
    <link href="http://52fhy.github.io/2015/07/13/javascript/Modular_programming_Javascript_2-AMD_standard/"/>
    <id>http://52fhy.github.io/2015/07/13/javascript/Modular_programming_Javascript_2-AMD_standard/</id>
    <published>2015-07-13T07:27:42.000Z</published>
    <updated>2015-07-14T12:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列的第一部分介绍了Javascript模块的基本写法，今天介绍如何规范地使用模块。</p>
<h2 id="七、模块的规范"><a href="#七、模块的规范" class="headerlink" title="七、模块的规范"></a>七、模块的规范</h2><p>先想一想，为什么模块很重要？</p>
<p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p>
<a id="more"></a>
<p>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。</p>
<p>目前，通行的Javascript模块规范共有两种：<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="external">CommonJS</a>和<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>。我主要介绍AMD，但是要先从CommonJS讲起。</p>
<h2 id="八、CommonJS"><a href="#八、CommonJS" class="headerlink" title="八、CommonJS"></a>八、CommonJS</h2><p>2009年，美国程序员Ryan Dahl创造了<a href="http://nodejs.org/" target="_blank" rel="external">node.js</a>项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p>node.js的<a href="http://nodejs.org/docs/latest/api/modules.html" target="_blank" rel="external">模块系统</a>，就是参照<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="external">CommonJS</a>规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　var math = require(&apos;math&apos;);</div></pre></td></tr></table></figure></p>
<p>然后，就可以调用模块提供的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　var math = require(&apos;math&apos;);</div><div class="line">　　math.add(2,3); // 5</div></pre></td></tr></table></figure></p>
<p>因为这个系列主要针对浏览器编程，不涉及node.js，所以对CommonJS就不多做介绍了。我们在这里只要知道，require()用于加载模块就行了。</p>
<h2 id="九、浏览器环境"><a href="#九、浏览器环境" class="headerlink" title="九、浏览器环境"></a>九、浏览器环境</h2><p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　var math = require(&apos;math&apos;);</div><div class="line">　　math.add(2, 3);</div></pre></td></tr></table></figure></p>
<p>第二行<code>math.add(2,3)</code>，在第一行 require(‘math’) 之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用  <code>&quot;同步加载&quot;（synchronous）</code>，只能采用<code>&quot;异步加载&quot;（asynchronous）</code>。这就是AMD规范诞生的背景。</p>
<h2 id="十、AMD"><a href="#十、AMD" class="headerlink" title="十、AMD"></a>十、AMD</h2><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a>是<code>&quot;Asynchronous Module Definition&quot;</code>的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD也采用<code>require()</code>语句加载模块，但是不同于CommonJS，它要求两个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　require([module], callback);</div></pre></td></tr></table></figure></p>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　require([&apos;math&apos;], function (math) &#123;</div><div class="line">　　　　math.add(2, 3);</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p><code>math.add()</code>与<code>math模块</code>加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p>
<p>目前，主要有两个Javascript库实现了AMD规范：<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="external">curl.js</a>。本系列的第三部分，将通过介绍require.js，进一步讲解AMD的用法，以及如何将模块化编程投入实战。<br>（完）</p>
<blockquote>
<p>作者： 阮一峰<br>日期： 2012年10月26日<br>来源： <a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列的第一部分介绍了Javascript模块的基本写法，今天介绍如何规范地使用模块。&lt;/p&gt;
&lt;h2 id=&quot;七、模块的规范&quot;&gt;&lt;a href=&quot;#七、模块的规范&quot; class=&quot;headerlink&quot; title=&quot;七、模块的规范&quot;&gt;&lt;/a&gt;七、模块的规范&lt;/h2&gt;&lt;p&gt;先想一想，为什么模块很重要？&lt;/p&gt;
&lt;p&gt;因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://52fhy.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Javascript模块化编程（一）：模块的写法</title>
    <link href="http://52fhy.github.io/2015/07/13/javascript/Modular_programming_Javascript_1-Module_writing/"/>
    <id>http://52fhy.github.io/2015/07/13/javascript/Modular_programming_Javascript_1-Module_writing/</id>
    <published>2015-07-13T06:22:42.000Z</published>
    <updated>2015-07-14T12:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着网站逐渐变成”互联网应用程序”，嵌入网页的Javascript代码越来越庞大，越来越复杂。</p>
<p>网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。</p>
<a id="more"></a>
<p>Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（正在制定中的<a href="http://en.wikipedia.org/wiki/ECMAScript" target="_blank" rel="external">ECMAScript标准</a>第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用。）</p>
<p>Javascript社区做了很多努力，在现有的运行环境中，实现”模块”的效果。本文总结了当前＂Javascript模块化编程＂的最佳实践，说明如何投入实用。虽然这不是初级教程，但是只要稍稍了解Javascript的基本语法，就能看懂。</p>
<h2 id="一、原始写法"><a href="#一、原始写法" class="headerlink" title="一、原始写法"></a>一、原始写法</h2><p>模块就是实现特定功能的一组方法。<br>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　&#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="comment">//...</span></div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。<br>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<h2 id="二、对象写法"><a href="#二、对象写法" class="headerlink" title="二、对象写法"></a>二、对象写法</h2><p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</div><div class="line">　　　　_count : <span class="number">0</span>,</div><div class="line">　　　　m1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//...</span></div><div class="line">　　　　&#125;,</div><div class="line">　　　　m2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//...</span></div><div class="line">　　　　&#125;</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure></p>
<p>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　module1.m1();</div></pre></td></tr></table></figure></p>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　module1._count = 5;</div></pre></td></tr></table></figure></p>
<h2 id="三、立即执行函数写法"><a href="#三、立即执行函数写法" class="headerlink" title="三、立即执行函数写法"></a>三、立即执行函数写法</h2><p>使用”<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="external">立即执行函数</a>“（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">　　var module1 = (function()&#123;</div><div class="line">　　　　var _count = 0;</div><div class="line">　　　　var m1 = function()&#123;</div><div class="line">　　　　　　//...</div><div class="line">　　　　&#125;;</div><div class="line">　　　　var m2 = function()&#123;</div><div class="line">　　　　　　//...</div><div class="line">　　　　&#125;;</div><div class="line">　　　　return &#123;</div><div class="line">　　　　　　m1 : m1,</div><div class="line">　　　　　　m2 : m2</div><div class="line">　　　　&#125;;</div><div class="line">　　&#125;)();</div></pre></td></tr></table></figure></p>
<p>使用上面的写法，外部代码无法读取内部的_count变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　console.info(module1._count); //undefined</div></pre></td></tr></table></figure></p>
<p>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p>
<h2 id="四、放大模式"><a href="#四、放大模式" class="headerlink" title="四、放大模式"></a>四、放大模式</h2><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　var module1 = (function (mod)&#123;</div><div class="line">　　　　mod.m3 = function () &#123;</div><div class="line">　　　　　　//...</div><div class="line">　　　　&#125;;</div><div class="line">　　　　return mod;</div><div class="line">　　&#125;)(module1);</div></pre></td></tr></table></figure></p>
<p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<h2 id="五、宽放大模式（Loose-augmentation）"><a href="#五、宽放大模式（Loose-augmentation）" class="headerlink" title="五、宽放大模式（Loose augmentation）"></a>五、宽放大模式（Loose augmentation）</h2><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　var module1 = ( function (mod)&#123;</div><div class="line">　　　　//...</div><div class="line">　　　　return mod;</div><div class="line">　　&#125;)(window.module1 || &#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。</p>
<h2 id="六、输入全局变量"><a href="#六、输入全局变量" class="headerlink" title="六、输入全局变量"></a>六、输入全局变量</h2><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　var module1 = (function ($, YAHOO) &#123;</div><div class="line">　　　　//...</div><div class="line">　　&#125;)(jQuery, YAHOO);</div></pre></td></tr></table></figure></p>
<p>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，参见Ben Cherry的著名文章<a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth" target="_blank" rel="external">《JavaScript Module Pattern: In-Depth》</a>。</p>
<p>这个系列的第二部分，将讨论如何在浏览器环境组织不同的模块、管理模块之间的依赖性。<br>（完）</p>
<blockquote>
<p>作者： 阮一峰<br>日期： 2012年10月26日<br>来源： <a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着网站逐渐变成”互联网应用程序”，嵌入网页的Javascript代码越来越庞大，越来越复杂。&lt;/p&gt;
&lt;p&gt;网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://52fhy.github.io/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://52fhy.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB——第八天 PHP操作mongodb</title>
    <link href="http://52fhy.github.io/2015/07/12/mongodb/MongoDB%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AB%E5%A4%A9%20PHP%E6%93%8D%E4%BD%9Cmongodb/"/>
    <id>http://52fhy.github.io/2015/07/12/mongodb/MongoDB——第八天 PHP操作mongodb/</id>
    <published>2015-07-12T01:55:00.000Z</published>
    <updated>2015-07-12T01:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="PHP安装MongoDB扩展驱动"><a href="#PHP安装MongoDB扩展驱动" class="headerlink" title="PHP安装MongoDB扩展驱动"></a>PHP安装MongoDB扩展驱动</h2><p>window上安装 MongoDB PHP扩展：</p>
<a id="more"></a>
<p>Github上已经提供了用于window平台的预编译php mongodb驱动二进制包(<a href="https://s3.amazonaws.com/drivers.mongodb.org/php/index.html" target="_blank" rel="external">下载地址</a>)，你可以下载与你php对应的版本，但是你需要注意以下几点问题：</p>
<p>1.安装的版本要与安装的PHP版本一致，例如php_mongo-1.6.8-5.4-vc9.dll运行环境是PHP5.4_ts_x86版本，且系统环境至少为vc9。</p>
<p>2.’Thread safe’（线程安全）是运行在Apache上以模块的PHP上，如果你以CGI的模式运行PHP，请选择非线程安全模式（’ non-thread safe’）。</p>
<p>3.下载完你需要的二进制包后，解压压缩包，将’php_mongo.dll’文件添加到你的PHP扩展目录中（ext）。ext目录通常在PHP安装目录下的ext目录。</p>
<p>打开php配置文件 php.ini 添加以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension=php_mongo.dll</div></pre></td></tr></table></figure></p>
<p>重启服务器。<br>通过浏览器访问phpinfo，如果安装成功，就会看到mongo。</p>
<h2 id="PHP操作mongodb"><a href="#PHP操作mongodb" class="headerlink" title="PHP操作mongodb"></a>PHP操作mongodb</h2><p>PHP已经提供了一系列的Mongo操作类：<br><a href="http://php.net/manual/zh/book.mongo.php" target="_blank" rel="external">http://php.net/manual/zh/book.mongo.php</a></p>
<p><code>MongoClient类</code><br>这个类用于创建和管理连接。</p>
<p><code>MongoClient</code><br>基本用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$m = new MongoClient(); // 连接</div><div class="line">$db = $m-&gt;foo; // 获取名称为 &quot;foo&quot; 的数据库</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Table of Contents</div><div class="line">MongoClient::close — 关闭连接</div><div class="line">MongoClient::connect — 连接到数据库服务器</div><div class="line">MongoClient::__construct — 创建一个新的数据库连接对象</div><div class="line">MongoClient::dropDB — 删除一个数据库 [已废弃]</div><div class="line">MongoClient::__get — 取得一个数据库</div><div class="line">MongoClient::getConnections — 返回所有已打开连接的信息</div><div class="line">MongoClient::getHosts — 更新所有关联主机的状态信息</div><div class="line">MongoClient::getReadPreference — 获取此连接的读取首选项</div><div class="line">MongoClient::getWriteConcern — Get the write concern for this connection</div><div class="line">MongoClient::killCursor — Kills a specific cursor on the server</div><div class="line">MongoClient::listDBs — 列出所有有效数据库</div><div class="line">MongoClient::selectCollection — 获取数据库的文档集</div><div class="line">MongoClient::selectDB — 获取一个数据库</div><div class="line">MongoClient::setReadPreference — 为该连接设置读取选项</div><div class="line">MongoClient::setWriteConcern — Set the write concern for this connection</div><div class="line">MongoClient::__toString — 该连接的字符串表达方式</div></pre></td></tr></table></figure>
<p><code>MongoDB类</code><br>该类的实例用于和数据库进行交互。例如：要获取一个数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$m = new MongoClient(); // 连接</div><div class="line">$db = $m-&gt;selectDB(&quot;test&quot;);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Table of Contents</div><div class="line"></div><div class="line">MongoDB::authenticate — 登录到数据库</div><div class="line">MongoDB::command — 执行一条 Mongo 指令</div><div class="line">MongoDB::__construct — 选择一个数据库</div><div class="line">MongoDB::createCollection — 创建一个集合</div><div class="line">MongoDB::createDBRef — 创建数据库引用</div><div class="line">MongoDB::drop — 丢弃数据库</div><div class="line">MongoDB::dropCollection — Drops a collection [deprecated]</div><div class="line">MongoDB::execute — 在数据库服务器上运行JavaScript</div><div class="line">...</div></pre></td></tr></table></figure>
<p><code>MongoCollection类</code><br>提供对集合的操作，如增删查改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Table of Contents</div><div class="line"></div><div class="line">MongoCollection::aggregate — Perform an aggregation using the aggregation framework</div><div class="line">MongoCollection::aggregateCursor — Execute an aggregation pipeline command and retrieve results through a cursor</div><div class="line">MongoCollection::batchInsert — Inserts multiple documents into this collection</div><div class="line">MongoCollection::__construct — 创建一个新的集合</div><div class="line">MongoCollection::count — 返回集合中的文档数量</div><div class="line">MongoCollection::createDBRef — 创建一个数据库引用</div><div class="line">MongoCollection::createIndex — Creates an index on the specified field(s) if it does not already exist.</div><div class="line">MongoCollection::deleteIndex — Deletes an index from this collection</div><div class="line">MongoCollection::deleteIndexes — 删除集合的所有索引</div><div class="line">MongoCollection::distinct — 获取集合里指定键的不同值的列表。</div><div class="line">MongoCollection::drop — 删除该集合</div><div class="line">MongoCollection::ensureIndex — Creates an index on the specified field(s) if it does not already exist.</div><div class="line">MongoCollection::find — 查询该集合，并返回结果集的 MongoCursor</div><div class="line">MongoCollection::findAndModify — Update a document and return it</div><div class="line">MongoCollection::findOne — Queries this collection, returning a single element</div><div class="line">MongoCollection::__get — Gets a collection</div><div class="line">MongoCollection::getDBRef — Fetches the document pointed to by a database reference</div><div class="line">MongoCollection::getIndexInfo — Returns information about indexes on this collection</div><div class="line">MongoCollection::getName — 返回这个集合的名称</div><div class="line">MongoCollection::getReadPreference — Get the read preference for this collection</div><div class="line">MongoCollection::getSlaveOkay — Get slaveOkay setting for this collection</div><div class="line">MongoCollection::getWriteConcern — Get the write concern for this collection</div><div class="line">MongoCollection::group — Performs an operation similar to SQL GROUP BY command</div><div class="line"></div><div class="line">MongoCollection::insert — 插入文档到集合中</div><div class="line">MongoCollection::parallelCollectionScan — Returns an array of cursors to iterator over a full collection in parallel</div><div class="line">MongoCollection::remove — 从集合中删除记录</div><div class="line">MongoCollection::save — 保存一个文档到集合</div><div class="line">MongoCollection::setReadPreference — Set the read preference for this collection</div><div class="line">MongoCollection::setSlaveOkay — Change slaveOkay setting for this collection</div><div class="line">MongoCollection::setWriteConcern — Set the write concern for this database</div><div class="line">MongoCollection::toIndexString — Converts keys specifying an index to its identifying string</div><div class="line">MongoCollection::__toString — String representation of this collection</div><div class="line">MongoCollection::update — Update records based on a given criteria</div><div class="line">MongoCollection::validate — Validates this collection</div></pre></td></tr></table></figure>
<p><code>MongoCursor类</code><br>用来遍历结果。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$cursor = $collection-&gt;find();</div><div class="line">var_dump(iterator_to_array($cursor));</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$m = new MongoClient();</div><div class="line"></div><div class="line">$db = $m-&gt;test; //选择test数据库</div><div class="line"></div><div class="line">$c = $db-&gt;user; //选择一个集合</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//find</div><div class="line"></div><div class="line"></div><div class="line">function get($c)&#123;</div><div class="line">    $list = $c-&gt;find();</div><div class="line">    </div><div class="line">    if(is_object($list))</div><div class="line">    foreach($list as $k=&gt;$vo)&#123;</div><div class="line">    </div><div class="line">        $data = array(</div><div class="line">            //&apos;id&apos; =&gt; $vo[&apos;_id&apos;],</div><div class="line">            &apos;name&apos; =&gt; $vo[&apos;name&apos;],</div><div class="line">            &apos;age&apos; =&gt; $vo[&apos;age&apos;],</div><div class="line">            &apos;birthday&apos; =&gt; $vo[&apos;birthday&apos;]</div><div class="line">        );</div><div class="line">         </div><div class="line">        if(empty($vo[&apos;age&apos;])) unset($data[&apos;age&apos;]);</div><div class="line">        if(empty($vo[&apos;birthday&apos;])) unset($data[&apos;birthday&apos;]);</div><div class="line">         </div><div class="line">        $res[] = $data;</div><div class="line">    &#125;</div><div class="line">    return  $res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function gets($c)&#123;</div><div class="line">    $list = $c-&gt;find();</div><div class="line">    var_dump(iterator_to_array($list));</div><div class="line">&#125;</div><div class="line"></div><div class="line">$list = get($c);</div><div class="line"></div><div class="line">//var_dump($list);</div><div class="line"></div><div class="line"></div><div class="line">//update</div><div class="line">$where = array(&apos;name&apos;=&gt;&apos;yjc&apos;);</div><div class="line">$new_arr = array(</div><div class="line">    &apos;name&apos; =&gt; &apos;yjc&apos;,</div><div class="line">    &apos;age&apos; =&gt; 25,</div><div class="line">    &apos;birthday&apos; =&gt; &apos;1992-02-18&apos;</div><div class="line">);</div><div class="line"></div><div class="line">//echo $res = $c-&gt;update($where, $new_arr); //全量更新，必须跟全部字段</div><div class="line"></div><div class="line">//局部更新</div><div class="line">$where = array(&apos;birthday&apos;=&gt;&apos;1992-02-18&apos;);</div><div class="line">$new_arr = array(&apos;$set&apos; =&gt;array(&apos;name&apos; =&gt; &apos;yujc&apos;, &apos;age&apos; =&gt; 25)); //注意用法，全部写在$set修改器数组里</div><div class="line">//$res = $c-&gt;update($where, $new_arr);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//新增</div><div class="line">$arr = array(</div><div class="line">    &apos;name&apos; =&gt; &apos;jiancai2&apos;,</div><div class="line">    &apos;age&apos; =&gt; 21,</div><div class="line">    &apos;birthday&apos; =&gt; &apos;1993-02-18&apos;</div><div class="line">);</div><div class="line">//$res = $c-&gt;insert($arr); var_dump($res);</div><div class="line"></div><div class="line"></div><div class="line">//删除</div><div class="line">$where = array(&apos;name&apos;=&gt;&apos;jiancai2&apos;);</div><div class="line">$res = $c-&gt;remove($where); var_dump($res);</div><div class="line"></div><div class="line"></div><div class="line">//count</div><div class="line">$user_num = $c-&gt;count();</div><div class="line">var_dump($user_num);</div><div class="line"></div><div class="line">//var_dump(get($c));</div><div class="line">gets($c);</div></pre></td></tr></table></figure>
<blockquote>
<p>参考：</p>
<ol>
<li>8天学通MongoDB——第八天 驱动实践<a href="http://www.cnblogs.com/huangxincheng/archive/2012/03/09/2386054.html" target="_blank" rel="external">http://www.cnblogs.com/huangxincheng/archive/2012/03/09/2386054.html</a></li>
<li>PHP安装MongoDB扩展 |菜鸟教程<br><a href="http://www.runoob.com/mongodb/mongodb-install-php-driver.html" target="_blank" rel="external">http://www.runoob.com/mongodb/mongodb-install-php-driver.html</a></li>
<li>php连接mongo：MongoDB PHP | 菜鸟教程<br><a href="http://www.runoob.com/mongodb/mongodb-php.html" target="_blank" rel="external">http://www.runoob.com/mongodb/mongodb-php.html</a></li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;PHP安装MongoDB扩展驱动&quot;&gt;&lt;a href=&quot;#PHP安装MongoDB扩展驱动&quot; class=&quot;headerlink&quot; title=&quot;PHP安装MongoDB扩展驱动&quot;&gt;&lt;/a&gt;PHP安装MongoDB扩展驱动&lt;/h2&gt;&lt;p&gt;window上安装 MongoDB PHP扩展：&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongo" scheme="http://52fhy.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB——第七天 运维技术</title>
    <link href="http://52fhy.github.io/2015/07/11/mongodb/MongoDB%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E5%A4%A9%20%E8%BF%90%E7%BB%B4%E6%8A%80/"/>
    <id>http://52fhy.github.io/2015/07/11/mongodb/MongoDB——第七天 运维技/</id>
    <published>2015-07-11T01:55:00.000Z</published>
    <updated>2015-07-11T01:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇我们以管理员的视角来看mongodb，作为一名管理员，我们经常接触到的主要有4个方面：</p>
<pre><code>1．安装部署
2．状态监控
3．安全认证
4．备份恢复
</code></pre><p>下面我们就一点一点的讲解。</p>
<a id="more"></a>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>我之前的文章都是采用console程序来承载，不过在生产环境中这并不是最佳实践，谁也不愿意在机器重启后满地找牙似找mongodb，在mongodb里面提供了一个叫做“服务寄宿”的模式，我想如果大家对wcf比较熟悉的话很容易听懂。好了，我们实践一下，这里我开一下D盘里面的mongodb。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --dbpath=D:\Projects\mongodb\db --logpath=D:\Projects\mongodb\logs\log.txt  --port 27017  --install</div></pre></td></tr></table></figure>
<p>这里要注意的有两点：<br>   <1> logpath: 当我们使用服务寄宿的时候，肯定不会用console来承载日志信息了。<br>   <2> install:   开启安装服务寄宿，把管理员的手工操作降低到最小。<br>   <3> 可能需要管理员权限。<br>   <4> 如果存在db\mongod.lock文件请删除</4></3></2></1></p>
<p>好了，console程序叫我看log日志，那我就看看，发现mongodb已经提示我们如何开启mongodb，接着我照做就是了。</p>
<pre><code>重新安装是reinstall
移除是remove
</code></pre><p>以后mongod会随着系统的启动而启动。</p>
<p>关于mongod的帮助<br>mongod –help 服务端的命令帮助<br>mongo –help  客户端的命令帮助<br>进入mongo后还可以输入help查看帮助</p>
<h2 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h2><p>监控可以让我们实时的了解数据库的健康状况以及性能调优，在mongodb里面给我们提供了三种方式。</p>
<p>1：http监视器</p>
<p>2：serverStatus()<br>    这个函数可以获取到mongodb的服务器统计信息，其中包括：全局锁，索引，用户操作行为等等这些统计信息，对管理员来说非常重要，具体的参数含义可以参考：<a href="http://www.cnblogs.com/xuegang/archive/2011/10/13/2210339.html。" target="_blank" rel="external">http://www.cnblogs.com/xuegang/archive/2011/10/13/2210339.html。</a></p>
<p>这个需要进入客户端运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.serverStatus()</div></pre></td></tr></table></figure>
<p>3：mongostat<br>前面那些统计信息再牛X，那也是静态统计，不能让我观看实时数据变化，还好，mongodb里面提供了这里要说的mongodstat监视器，这玩意会每秒刷新，在实际生产环境中大有用处。这个命令不是在客户端运行的，与mongod命令同级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongostat --port 27017</div></pre></td></tr></table></figure>
<h2 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h2><p>(1)3.x版本以下：<br>作为数据库软件，我们肯定不想谁都可以访问，为了确保数据的安全，mongodb也会像其他的数据库软件一样可以采用用户验证的方法，那么该怎么做呢？其实很简单，mongodb提供了addUser方法，还有一个注意点就是如果在admin数据库中添加将会被视为“超级管理员”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.addUser(&quot;admin&quot;,&quot;123456&quot;)</div></pre></td></tr></table></figure></p>
<p>如果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.addUser(&quot;test&quot;,&quot;123456&quot;,true)</div></pre></td></tr></table></figure></p>
<p>存在第三个参数，则表示是否是“只读用户”。</p>
<p>我们第一次登录时不是采用验证模式，现在我们使用–reinstall重启服务并以–auth验证模式登录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --dbpath=D:\Projects\mongodb\db --logpath=D:\Projects\mongodb\logs\log.txt  --port 27017 --auth  --reinstall</div></pre></td></tr></table></figure>
<p>好了，我们进入test集合翻翻数据看看情况，我们发现jack用户始终都是没有写入的权限，不管是授权或者未授权。</p>
<p>(2)3.x版本：<br>addUser在mongdb 3.0已经废弃了，对应的函数请用createUser，createUser接受两个参数，一个user object，一个可选参数用户角色，具体参考mongodb 3.0的文档:<a href="http://docs.mongodb.org/manual/reference/method/js-user-management/" target="_blank" rel="external">http://docs.mongodb.org/manual/reference/method/js-user-management/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.createUser()	Creates a new user.</div><div class="line">db.updateUser()	Updates user data.</div><div class="line">db.changeUserPassword()	Changes an existing user’s password.</div><div class="line">db.removeUser()	Deprecated. Removes a user from a database.</div><div class="line">db.dropAllUsers()	Deletes all users associated with a database.</div><div class="line">db.dropUser()	Removes a single user.</div><div class="line">db.grantRolesToUser()	Grants a role and its privileges to a user.</div><div class="line">db.revokeRolesFromUser()	Removes a role from a user.</div><div class="line">db.getUser()	Returns information about the specified user.</div><div class="line">db.getUsers()	Returns information about all users associated with a database.</div></pre></td></tr></table></figure></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;use test</div><div class="line">&gt;db.createUser(</div><div class="line">   &#123;</div><div class="line">     user: &quot;accountUser&quot;,</div><div class="line">     pwd: &quot;password&quot;,</div><div class="line">     roles: [ &quot;readWrite&quot;, &quot;dbAdmin&quot; ]</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h2><p>这玩意的重要性我想都不需要我来说了吧，这玩意要是搞不好会死人的,mongodb里面常用的手段有3种。</p>
<p>1： 直接copy<br>这个算是最简单的了，不过要注意一点，在服务器运行的情况下直接copy是很有风险的，可能copy出来时，数据已经遭到破坏，唯一能保证的就是要暂时关闭下服务器，copy完后重开。</p>
<p>2：mongodump和mongorestore<br>这个是mongo给我们提供的内置工具，很好用，能保证在不关闭服务器的情况下copy数据。为了操作方便，我们先删除授权用户。</p>
<p>使用mongodump备份比较慢，在备份复制集时还有些问题，后续会说到。但是，用来备份单个数据库、集合、子集合还是比较好的方法。</p>
<p>mongod未运行情况下：</p>
<p>备份全部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump -p 27017</div></pre></td></tr></table></figure></p>
<p>将在当前目录下创建dump目录，备份所有的数据库，所有的数据存储在.bson文件中，可以使用mongodb提供的bsondump工具来检索它。</p>
<p>备份test数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump -p 27017 -d test -o D:\Projects\mongodb\dump</div></pre></td></tr></table></figure></p>
<p>恢复时，使用mongorestore工具恢复<br>恢复整个数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongorestore --port 27017 D:\Projects\mongodb\dump</div></pre></td></tr></table></figure></p>
<p>恢复到特定的库和集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongorestore --db test --collection user --drop D:\Projects\mongodb\dump</div></pre></td></tr></table></figure></p>
<p>–drop 先删除原有数据库里面的数据</p>
<p>注意：<br>1、mongodump和mongorestore版本最好相匹配。<br>2、–dbpath and related flags are not supported in 3.0 tools.<br>3、–db与-d是一样的，即-表示缩写<br>4、使用mongodump –help查看更多命令(使用 - 和 / 都可以)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">mongodump --help</div><div class="line">Usage:</div><div class="line">  mongodump &lt;options&gt;</div><div class="line"></div><div class="line">Export the content of a running server into .bson files.</div><div class="line">Specify a database with -d and a collection with -c to only dump that database or collection.</div><div class="line"></div><div class="line">See http://docs.mongodb.org/manual/reference/program/mongodump/ for more information.</div><div class="line"></div><div class="line">general options:</div><div class="line">      /help                           print usage</div><div class="line">      /version                        print the tool version and exit</div><div class="line"></div><div class="line">verbosity options:</div><div class="line">  /v, /verbose                        more detailed log output (include</div><div class="line">                                      multiple times for more verbosity, e.g.</div><div class="line">                                      -vvvvv)</div><div class="line">      /quiet                          hide all log output</div><div class="line"></div><div class="line">connection options:</div><div class="line">  /h, /host:                          mongodb host to connect to</div><div class="line">                                      (setname/host1,host2 for replica sets)</div><div class="line">      /port:                          server port (can also use --host</div><div class="line">                                      hostname:port)</div><div class="line"></div><div class="line">authentication options:</div><div class="line">  /u, /username:                      username for authentication</div><div class="line">  /p, /password:                      password for authentication</div><div class="line">      /authenticationDatabase:        database that holds the user&apos;s credentials</div><div class="line">      /authenticationMechanism:       authentication mechanism to use</div><div class="line"></div><div class="line">namespace options:</div><div class="line">  /d, /db:                            database to use</div><div class="line">  /c, /collection:                    collection to use</div><div class="line"></div><div class="line">query options:</div><div class="line">  /q, /query:                         query filter, as a JSON string, e.g.,</div><div class="line">                                      &apos;&#123;x:&#123;$gt:1&#125;&#125;&apos;</div><div class="line">      /forceTableScan                 force a table scan</div><div class="line"></div><div class="line">output options:</div><div class="line">  /o, /out:                           output directory, or &apos;-&apos; for stdout</div><div class="line">                                      (defaults to &apos;dump&apos;)</div><div class="line">      /repair                         try to recover documents from damaged</div><div class="line">                                      data files (not supported by all storage</div><div class="line">                                      engines)</div><div class="line">      /oplog                          use oplog for taking a point-in-time</div><div class="line">                                      snapshot</div><div class="line">      /dumpDbUsersAndRoles            dump user and role definitions for the</div><div class="line">                                      specified database</div><div class="line">      /excludeCollection:             collection to exclude from the dump (may</div><div class="line">                                      be specified multiple times to exclude</div><div class="line">                                      additional collections)</div><div class="line">      /excludeCollectionsWithPrefix:  exclude all collections from the dump</div><div class="line">                                      that have the given prefix (may be</div><div class="line">                                      specified multiple times to exclude</div><div class="line">                                      additional prefixes)</div><div class="line">```	</div><div class="line">	</div><div class="line">	</div><div class="line">3：主从复制</div><div class="line">这个我在上上篇有所介绍，这里也不赘述了。</div><div class="line"></div><div class="line">其实上面的1，2两点都不能保证获取数据的实时性，因为我们在备份的时候可能还有数据灌在内存中不出来，那么我们想说能不能把数据暴力的刷到硬盘上，当然是可以的,mongodb给我们提供了fsync+lock机制就能满足我们提的需求。</div><div class="line"></div><div class="line">fsync+lock首先会把缓冲区数据暴力刷入硬盘，然后给数据库一个写入锁，其他实例的写入操作全部被阻塞，直到fsync+lock释放锁为止。这里就不测试了。</div><div class="line"></div><div class="line">加锁(需要use admin)：</div></pre></td></tr></table></figure>
<p>db.runCommand({“fsync”:1,”lock”:1})<br>```</p>
<p>释放锁：db.fsyncUnlock()<br>或者db.$cmd.sys.unlock.findOne()</p>
<blockquote>
<p>参考：<br>8天学通MongoDB——第七天 运维技术 - 一线码农 - 博客园<br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/03/08/2384571.html" target="_blank" rel="external">http://www.cnblogs.com/huangxincheng/archive/2012/03/08/2384571.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇我们以管理员的视角来看mongodb，作为一名管理员，我们经常接触到的主要有4个方面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1．安装部署
2．状态监控
3．安全认证
4．备份恢复
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面我们就一点一点的讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongo" scheme="http://52fhy.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB——第六天 分片技术</title>
    <link href="http://52fhy.github.io/2015/07/10/mongodb/MongoDB%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E5%A4%A9%20%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF/"/>
    <id>http://52fhy.github.io/2015/07/10/mongodb/MongoDB——第六天 分片技术/</id>
    <published>2015-07-10T01:55:00.000Z</published>
    <updated>2015-07-10T01:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在mongodb里面存在另一种集群，就是分片技术，跟sql server的表分区类似，我们知道当数据量达到T级别的时候，我们的磁盘，内存就吃不消了，针对这样的场景我们该如何应对。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><pre><code>mongodb采用将集合进行拆分，然后将拆分的数据均摊到几个片上的一种解决方案。图例分析：
</code></pre><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">从服务器1        从服务器2</div><div class="line">		\         /</div><div class="line">	路由服务器mongods  &lt;——&gt; config服务器   </div><div class="line">			|</div><div class="line">			|</div><div class="line">		  客户端</div></pre></td></tr></table></figure>
<p>下面我对这张图解释一下：<br><code>客户端</code>：客户端肯定说，你数据库分片不分片跟我没关系，我叫你干啥就干啥，没什么好商量的。<br><code>mongos</code>：首先我们要了解”片键“的概念，也就是说拆分集合的依据是什么？mongos就是一个路由服务器，它会根据管理员设置的“片键”将数据分摊到自己管理的mongod集群，数据和片的对应关系以及相应的配置信息保存在”config服务器”上。<br><code>从服务器</code>：一个普通的数据库实例，如果不分片的话，我们会直接连上mongod。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>首先我们准备4个mongodb程序，我这里是均摊在C，D，E，F盘上，当然你也可以做多个文件夹的形式（下面将采用目录的形式mongodb、mongodb2、mongodb3、mongodb4对应C，D，E，F盘）。</p>
<pre><code>mongodb   ---config  --port 2222
mongodb1  ---mongos  --port 3333
mongodb2  ---mongod     --port 4444
mongodb3  ---mongod  --port 5555
</code></pre><p>1：开启config服务器<br>    先前也说了，mongos要把mongod之间的配置放到config服务器里面，理所当然首先开启它，我这里就建立2222端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb\bin&gt;mongod --dbpath=D:\Projects\mongodb\db --port 2222</div></pre></td></tr></table></figure>
<p>2: 开启mongos服务器<br>    这里要注意的是我们开启的是mongos，不是mongod，同时指定下config服务器，这里我就开启D盘上的mongodb，端口3333。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongos --port 3333 --configdb=127.0.0.1:2222</div><div class="line">```	</div><div class="line">3：启动mongod服务器</div><div class="line">     对分片来说，也就是要添加片了，这里开启E，F盘的mongodb，端口为：4444，5555。</div></pre></td></tr></table></figure>
<p>mongod –dbpath=D:\Projects\mongodb3\db –port 4444<br>mongod –dbpath=D:\Projects\mongodb4\db –port 5555</p>
<p>2015-07-04T10:34:15.394+0800 I NETWORK  [initandlisten] waiting for connections on port 4444<br>2015-07-04T10:35:35.372+0800 I NETWORK  [initandlisten] waiting for connections on port 5555<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4： 服务配置</div><div class="line">    哈哈，是不是很兴奋，还差最后一点配置我们就可以大功告成。</div><div class="line">&lt;1&gt;先前图中也可以看到，我们client直接跟mongos打交道，也就说明我们要连接mongos服务器，然后将4444，5555的mongod交给mongos,添加分片也就是addshard()。</div></pre></td></tr></table></figure></p>
<p>D:\Projects\mongodb\bin&gt;mongo 127.0.0.1:3333/admin<br>connecting to: 127.0.0.1:3333/admin<br>mongos&gt;<br>mongos&gt; db.runCommand({“addshard”:”127.0.0.1:4444”,”allowLocal”:true})<br>{ “shardAdded” : “shard0000”, “ok” : 1 }<br>mongos&gt; db.runCommand({“addshard”:”127.0.0.1:5555”,”allowLocal”:true})<br>{ “shardAdded” : “shard0001”, “ok” : 1 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里要注意的是，在addshard中，我们也可以添加副本集，这样能达到更高的稳定性。</div><div class="line"></div><div class="line"> </div><div class="line">&lt;2&gt;片已经集群了，但是mongos不知道该如何切分数据，也就是我们先前所说的片键，在mongodb中设置片键要做两步:</div><div class="line"></div><div class="line">	1)开启数据库分片功能，命令很简单 enablesharding(),这里我就开启test数据库。</div><div class="line">	2)指定集合中分片的片键，这里我就指定为test.montest.name字段。</div></pre></td></tr></table></figure></p>
<p>db.runCommand({“enablesharding”:”test”})<br>db.runCommand({“shardcollection”:”test.montest”, “key”:{“name”:1}})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">5: 查看效果</div><div class="line">好了，至此我们的分片操作全部结束，接下来我们通过mongos向mongodb插入1w记录，然后通过printShardingStatus命令</div><div class="line">查看mongodb的数据分片情况。</div></pre></td></tr></table></figure></p>
<p>for(var i=0;i&lt;10000;i++){<br>    db.montest.insert({“name”:”yjc”+i, “age”:i});<br>}</p>
<p>mongos&gt; db.montest.count()<br>10000<br>mongos&gt; db.printShardingStatus()<br>— Sharding Status —<br>  sharding version: {<br>        “_id” : 1,<br>        “minCompatibleVersion” : 5,<br>        “currentVersion” : 6,<br>        “clusterId” : ObjectId(“559745db7ba8ba85959c9bfb”)<br>}<br>  shards:<br>        {  “_id” : “shard0000”,  “host” : “127.0.0.1:4444” }<br>        {  “_id” : “shard0001”,  “host” : “127.0.0.1:5555” }<br>  balancer:<br>        Currently enabled:  yes<br>        Currently running:  no<br>        Failed balancer rounds in last 5 attempts:  0<br>        Migration Results for the last 24 hours:<br>                1 : Success<br>  databases:<br>        {  “_id” : “admin”,  “partitioned” : false,  “primary” : “config” }<br>        {  “_id” : “test”,  “partitioned” : true,  “primary” : “shard0000” }<br>                test.montest<br>                        shard key: { “name” : 1 }<br>                        chunks:<br>                                shard0000       2<br>                                shard0001       1<br>                        { “name” : { “$minKey” : 1 } } –&gt;&gt; { “name” : “yjc1” } on : shard0001 Timestamp(2, 0)<br>                        { “name” : “yjc1” } –&gt;&gt; { “name” : “yjc6” } on : shard0000 Timestamp(2, 1)<br>                        { “name” : “yjc6” } –&gt;&gt; { “name” : { “$maxKey” : 1 } } on : shard0000 Timestamp(1, 3)<br>```</p>
<p>这里主要看三点信息：<br>1)shards：我们清楚的看到已经别分为两个片了，shard0000和shard0001。<br>2)databases: 这里有个partitioned字段表示是否分区，这里清楚的看到test已经分区。<br>3)chunks：这个很有意思，我们发现集合被砍成四段：<br>无穷小 —— yjc ,   yjc1 ——  yjc6,  yjc6 —— 无穷大。<br>分区情况为：2：1，从后面的 on shardXXXX也能看得出。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>问题：<br>1、在现有的数据库上做分片，怎么做？<br>2、一个分片Mongod进程挂掉了，是不是整个集合的查询就没有意义了啊？<br>发现只要有一个分片挂了，就查询不了数据了。</p>
<blockquote>
<p>参考：<br>8天学通MongoDB——第六天 分片技术 - 一线码农 - 博客园<br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/03/07/2383284.html" target="_blank" rel="external">http://www.cnblogs.com/huangxincheng/archive/2012/03/07/2383284.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mongodb里面存在另一种集群，就是分片技术，跟sql server的表分区类似，我们知道当数据量达到T级别的时候，我们的磁盘，内存就吃不消了，针对这样的场景我们该如何应对。&lt;/p&gt;
&lt;h2 id=&quot;分片&quot;&gt;&lt;a href=&quot;#分片&quot; class=&quot;headerlink&quot; title=&quot;分片&quot;&gt;&lt;/a&gt;分片&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;mongodb采用将集合进行拆分，然后将拆分的数据均摊到几个片上的一种解决方案。图例分析：
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="mongo" scheme="http://52fhy.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB——第五天 主从复制</title>
    <link href="http://52fhy.github.io/2015/07/09/mongodb/MongoDB%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E5%A4%A9%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://52fhy.github.io/2015/07/09/mongodb/MongoDB——第五天 主从复制/</id>
    <published>2015-07-09T01:55:00.000Z</published>
    <updated>2015-07-09T01:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>1.这种架构有如下的好处：<br> <1>  数据备份。<br> <2>  数据恢复。<br> <3>  读写分离。</3></2></1></p>
 <a id="more"></a>
<p>2.下面我们就一一实践<br> 实际应用中我们肯定是多服务器部署，限于自己懒的装虚拟机，就在一台机器上实践了。</p>
<p>第一步：我们把mongodb文件夹放在D盘和E盘，模拟放在多服务器上。<br>第二步：启动D盘上的mongodb，把该数据库指定为主数据库，其实命令很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;mongodb --dbpath=&apos;XXX&apos; --master</div></pre></td></tr></table></figure></p>
<p>端口还是默认的27017.</p>
<p>开启主服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb\bin&gt;mongod --dbpath=D:\Projects\mongodb\db --master</div><div class="line"></div><div class="line">2015-07-02T22:53:13.738+0800 I CONTROL  [initandlisten] options: &#123; master: true, storage: &#123; dbPath: &quot;D:\Projects\mongodb\db&quot; &#125; &#125;</div><div class="line">2015-07-02T22:53:13.814+0800 I REPL     [initandlisten] ******</div><div class="line">2015-07-02T22:53:13.814+0800 I REPL     [initandlisten] creating replication oplog of size: 50MB...</div><div class="line">2015-07-02T22:53:13.921+0800 I REPL     [initandlisten] ******</div><div class="line">2015-07-02T22:53:13.924+0800 I NETWORK  [initandlisten] waiting for connections on port 27017</div></pre></td></tr></table></figure></p>
<p>第三步：同样的方式启动E盘上的mongodb，指定该数据库为从属数据库，命令也很简单，当然我们要换一个端口，比如：8888。<br>source 表示主数据库的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;mongod --dbpath=xxxx --port=8888 --slave --source=127.0.0.1:27017</div></pre></td></tr></table></figure>
<p>开启从服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongod --dbpath=D:\Projects\mongodb2\db --slave --port 8888 --source=17.0.0.1:27017</div></pre></td></tr></table></figure></p>
<p>报错了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2015-07-02T23:07:44.152+0800 I REPL     [replslave] repl: --source 127.0.0.1:2222 != 17.0.0.1:27017 from local.sources collection</div></pre></td></tr></table></figure></p>
<p>这是由于之前误操作，127.0.0.1:2222 != 17.0.0.1:27017，IP地址错了。可以删掉D:\Projects\mongodb2\db的db文件夹新建。尝试修改主服务器的端口。</p>
<p>一般还可能有下面两个错误：<br>(1)D:\Projects\mongodb2\db的db文件夹不存在导致的错误；创建该文件夹即可。<br>(2)D:\Projects\mongodb2\db下存在mongod.lock文件。删掉即可。</p>
<p>重新来：<br>开主服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb\bin&gt;mongod --dbpath=D:\Projects\mongodb\db --master --port 2222</div></pre></td></tr></table></figure></p>
<p>提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2015-07-02T23:10:04.004+0800 I CONTROL  [initandlisten] options: &#123; master: true, net: &#123; port: 2222 &#125;, storage: &#123; dbPath: &quot;D:\Proje</div><div class="line">cts\mongodb\db&quot; &#125; &#125;</div><div class="line">2015-07-02T23:10:04.063+0800 I NETWORK  [initandlisten] waiting for connections on port 2222</div></pre></td></tr></table></figure></p>
<p>成功。</p>
<p>开启从服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongod --dbpath=D:\Projects\mongodb2\db --slave --port 3333 --source=127.0.0.1:2222</div></pre></td></tr></table></figure></p>
<p>提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2015-07-02T23:26:44.602+0800 I CONTROL  [initandlisten] allocator: tcmalloc</div><div class="line">2015-07-02T23:26:44.603+0800 I CONTROL  [initandlisten] options: &#123; net: &#123; port: 3333 &#125;, slave: true, source: &quot;127.0.0.1:2222&quot;, sto</div><div class="line">rage: &#123; dbPath: &quot;D:\Projects\mongodb2\db&quot; &#125; &#125;</div><div class="line">2015-07-02T23:26:44.621+0800 I NETWORK  [initandlisten] waiting for connections on port 3333</div><div class="line">2015-07-02T23:26:53.106+0800 I REPL     [replslave] repl: sleep 1 sec before next pass</div><div class="line">2015-07-02T23:26:54.109+0800 I REPL     [replslave] repl: syncing from host:127.0.0.1:2222</div><div class="line">2015-07-02T23:27:03.104+0800 I REPL     [replslave] repl:   applied 1 operations</div><div class="line">2015-07-02T23:27:03.106+0800 I REPL     [replslave] repl:  end sync_pullOpLog syncedTo: Jul 02 23:26:58 55955842:1</div></pre></td></tr></table></figure></p>
<p>成功。从中我们发现了一条：“applied 1 operations”这样的语句，并且发生的时间相隔10s，也就说明从属数据库每10s就向主数据库同步数据，同步依据也就是寻找主数据库的”OpLog“日志，可以在图中红色区域内发现”sync_pullOpLog“字样。</p>
<p>接下来，我们可以打开客户端，连接从服务器进行测试了。再打开一个命令行窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongo 127.0.0.1:3333</div><div class="line">connecting to: 127.0.0.1:3333/test</div><div class="line"></div><div class="line">&gt; db.user.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;55935f703cb05382291e9132&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 22 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360ae3cb05382291e9134&quot;), &quot;name&quot; : &quot;hxc&quot;, &quot;birthday&quot; : &quot;1989-2-2&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360bd3cb05382291e9135&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360d13cb05382291e9136&quot;), &quot;name&quot; : &quot;joe&quot;, &quot;birthday&quot; : &quot;1989-2-22&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360df3cb05382291e9137&quot;), &quot;name&quot; : &quot;mary&quot;, &quot;birthday&quot; : &quot;1989-3-12&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360e93cb05382291e9138&quot;), &quot;name&quot; : &quot;jr&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot; &#125;</div><div class="line">&gt; db.person.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;558fd39d02d9b5bcf004aaf5&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 5, &quot;address&quot; : &#123; &quot;city&quot; : &quot;beijing&quot; &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5590ac85c8e4762462ebbab2&quot;), &quot;name&quot; : &quot;liyi&quot;, &quot;age&quot; : 20, &quot;address&quot; : &#123; &quot;province&quot; : &quot;hubei&quot;, &quot;city&quot; : &quot;wuhan&quot;</div><div class="line">&#125;, &quot;favourite&quot; : [ &quot;music&quot;, &quot;movie&quot; ] &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5590adecc8e4762462ebbab3&quot;), &quot;name&quot; : &quot;lier&quot;, &quot;age&quot; : 10, &quot;adress&quot; : &#123; &quot;province&quot; : &quot;hubei&quot;, &quot;city&quot; : &quot;yichang&quot;</div><div class="line"> &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5590b92aeb60c2633d9cfa24&quot;), &quot;name&quot; : &quot;yjc2&quot;, &quot;age&quot; : 25 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;55926102f431047603d95187&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 22 &#125;</div></pre></td></tr></table></figure></p>
<p>好家伙，数据全都有了！数据已经同步更新成功！</p>
<p>3.如果我还想增加一台从属数据库，但是我不想在启动时就指定，而是后期指定，那么mongodb可否做的到呢？答案肯定是可以的。我们的主或者从属数据库中都有一个叫做local的集合，主要是用于存放内部复制信息。</p>
<p>主服务器不用关，我们可以再新增一台或者关掉从服务器，重新开启从服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongod --dbpath=D:\Projects\mongodb2\db --slave --port 3333</div><div class="line"></div><div class="line">2015-07-03T09:50:18.777+0800 I CONTROL  [initandlisten] allocator: tcmalloc</div><div class="line">2015-07-03T09:50:18.777+0800 I CONTROL  [initandlisten] options: &#123; net: &#123; port: 3333 &#125;, slave: true, storage: &#123; dbPath: &quot;D:\Projec</div><div class="line">ts\mongodb2\db&quot; &#125; &#125;</div><div class="line">2015-07-03T09:50:18.780+0800 I INDEX    [initandlisten] allocating new ns file D:\Projects\mongodb2\db\local.ns, filling with zero</div><div class="line">es...</div><div class="line">2015-07-03T09:50:19.129+0800 I STORAGE  [FileAllocator] allocating new datafile D:\Projects\mongodb2\db\local.0, filling with zero</div><div class="line">es...</div><div class="line">2015-07-03T09:50:19.130+0800 I STORAGE  [FileAllocator] creating directory D:\Projects\mongodb2\db\_tmp</div><div class="line">2015-07-03T09:50:19.542+0800 I STORAGE  [FileAllocator] done allocating datafile D:\Projects\mongodb2\db\local.0, size: 64MB,  too</div><div class="line">k 0.406 secs</div><div class="line">2015-07-03T09:50:19.695+0800 I NETWORK  [initandlisten] waiting for connections on port 3333</div><div class="line">2015-07-03T09:50:20.692+0800 I REPL     [replslave] no source given, add a master to local.sources to start replication</div><div class="line">2015-07-03T09:50:20.692+0800 I REPL     [replslave] repl: sleep 20 sec before next pass</div></pre></td></tr></table></figure></p>
<p>看上面的log，提示没有主数据库，没关系，某一天我们良心发现，给他后期补贴一下，哈哈，再开一个cmd窗口，打开客户端，语句也就是在sources中add一个host地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongo 127.0.0.1:3333</div><div class="line">connecting to: 127.0.0.1:3333/test</div></pre></td></tr></table></figure>
<p>使用local集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; use local</div><div class="line">switched to db local</div></pre></td></tr></table></figure></p>
<p>从主服务器127.0.0.1:2222复制数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; db.sources.insert(&#123;&quot;host&quot;:&quot;127.0.0.1:2222&quot;&#125;)</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line"></div><div class="line">&gt; db.sources.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5595ecd1143aa60c5492e195&quot;), &quot;host&quot; : &quot;127.0.0.1:2222&quot;, &quot;source&quot; : &quot;main&quot;, &quot;syncedTo&quot; : Timestamp(1435888931, 1) &#125;</div></pre></td></tr></table></figure></p>
<p>使用test集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; use test;</div><div class="line">switched to db test</div><div class="line">&gt; db.user.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;55935f703cb05382291e9132&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 22 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360ae3cb05382291e9134&quot;), &quot;name&quot; : &quot;hxc&quot;, &quot;birthday&quot; : &quot;1989-2-2&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360bd3cb05382291e9135&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360d13cb05382291e9136&quot;), &quot;name&quot; : &quot;joe&quot;, &quot;birthday&quot; : &quot;1989-2-22&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360df3cb05382291e9137&quot;), &quot;name&quot; : &quot;mary&quot;, &quot;birthday&quot; : &quot;1989-3-12&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360e93cb05382291e9138&quot;), &quot;name&quot; : &quot;jr&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot; &#125;</div></pre></td></tr></table></figure></p>
<p>最后发现数据也同步到127.0.0.1:3333这台后期同步的从属数据库中….</p>
<p>客户端插入一条数据试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.insert(&#123;&quot;name&quot;:&quot;mary&quot;, &quot;age&quot;: 23&#125;)</div><div class="line">WriteResult(&#123; &quot;writeError&quot; : &#123; &quot;code&quot; : undefined, &quot;errmsg&quot; : &quot;not master&quot; &#125; &#125;)</div></pre></td></tr></table></figure></p>
<p>切换连接到主服务器就可以新增了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongo 127.0.0.1:2222</div><div class="line">&gt; db.user.insert(&#123;&quot;name&quot;:&quot;mary&quot;, &quot;age&quot;: 23&#125;)</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div></pre></td></tr></table></figure></p>
<p>再连接到从服务器发现数据也同步了，即不用重新去追加数据。</p>
<p>4.读写分离<br>这种手段在大一点的架构中都有实现，在mongodb中其实很简单，在默认的情况下，从属数据库不支持数据的读取，但是没关系，在驱动中给我们提供了一个叫做“slaveOkay”（？）来让我们可以显示的读取从属数据库来减轻主数据库的性能压力。</p>
<p>主从复制的选项<br>–only 在从节点上指定只复制特定的某个数据库(默认是复制所有数据库)<br>–slavedelay 用在从节点上,当应用主节点的操作时,从节点增加延时复制(单位秒).这样就能轻松设置延时从节点,这种节点对用户<br>无意中删除重要文档或者插入垃圾数据等有防护作用,这些不良操作都会被复制到所有的从节点上,通过延时执行操作,<br>可以有个恢复的时间差.<br>–fastsync 以主节点的数据快照为基础启动从节点.如果数据目录一开始是主节点的数据快照,从节点用这个选项启动要比<br>做完整的同步快的多.<br>–autoresync 如果从节点与主节点不同步了,则自动重新同步<br>–oplogsize 主节点oplog的大小(单位MB)</p>
<h2 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h2><p>这个也是很牛X的主从集群，不过跟上面的集群还是有两点区别的。</p>
<p><1>该集群没有特定的主数据库。</1></p>
<p><2>如果哪个主数据库宕机了，集群中就会推选出一个从属数据库作为主数据库顶上，这就具备了自动故障恢复功能。</2></p>
<p>好，我们现在就来试一下，首先把所有的cmd窗口关掉重新来，清掉db下的所有文件（不清除后续操作可能会报错）。</p>
<p>第一步:  既然我们要建立集群，就得取个集群名字，这里就取名shopex, –replSet表示让服务器知道shopex下还有其他数据库，</p>
<p>这里就把D盘里面的mongodb程序打开，端口为2222。指定端口为3333是shopex集群下的另一个数据库服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb\bin&gt;mongod --dbpath=D:\Projects\mongodb\db --port 2222 --replSet shopex/127.0.0.1:3333</div><div class="line"></div><div class="line">2015-07-04T09:05:37.568+0800 I CONTROL  [initandlisten] allocator: tcmalloc</div><div class="line">2015-07-04T09:05:37.568+0800 I CONTROL  [initandlisten] options: &#123; net: &#123; port: 2222 &#125;, replication: &#123; replSet: &quot;shopex/127.0.0.1:</div><div class="line">3333&quot; &#125;, storage: &#123; dbPath: &quot;D:\Projects\mongodb\db&quot; &#125; &#125;</div><div class="line">2015-07-04T09:05:37.601+0800 I NETWORK  [initandlisten] waiting for connections on port 2222</div></pre></td></tr></table></figure>
<p>第二步:  既然上面说3333是另一个数据库服务器，不要急，现在就来开，这里把另外一个目录mongodb2的mongodb程序打开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongod --dbpath=D:\Projects\mongodb2\db --port 3333 --replSet shopex/127.0.0.1:2222</div><div class="line"></div><div class="line">2015-07-04T09:08:11.815+0800 I CONTROL  [initandlisten] allocator: tcmalloc</div><div class="line">2015-07-04T09:08:11.815+0800 I CONTROL  [initandlisten] options: &#123; net: &#123; port: 3333 &#125;, replication: &#123; replSet: &quot;shopex/127.0.0.1:</div><div class="line">2222&quot; &#125;, storage: &#123; dbPath: &quot;D:\Projects\mongodb2\db&quot; &#125; &#125;</div><div class="line">ingDocument Did not find replica set configuration document in local.system.replset</div><div class="line">2015-07-04T09:08:12.905+0800 I NETWORK  [initandlisten] waiting for connections on port 3333</div></pre></td></tr></table></figure>
<p>第三步：  ok，看看上面的日志，似乎我们还没有做完，是的，log信息告诉我们要初始化一下“副本集“，既然日志这么说，那我也就这么做，随便连接一下哪个服务器都行，不过一定要进入admin集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">D:\Projects\mongodb2\bin&gt;mongo 127.0.0.1:2222/admin</div><div class="line"></div><div class="line">db.runCommand(&#123;&quot;replSetInitiate&quot;:&#123;</div><div class="line">	&quot;_id&quot;:&quot;shopex&quot;,</div><div class="line">	&quot;members&quot; :[</div><div class="line">	&#123;</div><div class="line">		&quot;_id&quot; :1 ,</div><div class="line">		&quot;host&quot;:&quot;127.0.0.1:2222&quot;,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		&quot;_id&quot; :2 ,</div><div class="line">		&quot;host&quot;:&quot;127.0.0.1:3333&quot;,</div><div class="line">	&#125;,</div><div class="line">	]</div><div class="line">&#125;&#125;)</div></pre></td></tr></table></figure>
<p>第一次设置报告了一个错误：<br>“errmsg” : “‘127.0.0.1:3333’ has data already, cannot initiate set.”</p>
<p>原因是我没有清除D:\Projects\mongodb2\下的db。关闭D:\Projects\mongodb2\服务器并删除db下的文件后重新打开mongodb2服务器，并再次设置初始化：显示ok。</p>
<p>第四步： 开启成功后，我们要看看谁才能成为主数据库服务器，可以看到端口为2222的已经成为主数据库服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongodb1---cmd:</div><div class="line">2015-07-04T09:16:02.925+0800 I REPL     [ReplicationExecutor] replSet election succeeded, assuming primary role</div><div class="line">2015-07-04T09:16:02.928+0800 I REPL     [ReplicationExecutor] transition to PRIMARY</div><div class="line"></div><div class="line">mongodb2---cmd:</div><div class="line">2015-07-04T09:16:07.059+0800 I REPL     [ReplicationExecutor] transition to RECOVERING</div><div class="line">2015-07-04T09:16:07.062+0800 I REPL     [ReplicationExecutor] transition to SECONDARY</div></pre></td></tr></table></figure></p>
<p>第五步：我们知道sql server里面有一个叫做仲裁服务器，那么mongodb中也是有的，跟sql server一样，仲裁只参与投票选举，这里我们把mongodb3的mongodb作为仲裁服务器，然后指定shopex集群中的任一个服务器端口，这里就指定2222。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --dbpath=D:\Projects\mongodb3\db --port 4444 --replSet shopex/127.0.0.1:2222</div></pre></td></tr></table></figure>
<p>然后我们在admin集合中使用rs.addArb()追加即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; rs.addArb(&quot;127.0.0.1:4444&quot;)</div><div class="line">&#123; &quot;ok&quot; : 1 &#125;</div></pre></td></tr></table></figure></p>
<p>追加好了之后，我们使用rs.status()来查看下集群中的服务器状态，图中我们可以清楚的看到谁是主，还是从，还是仲裁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">shopex:PRIMARY&gt; rs.status()</div><div class="line">&#123;</div><div class="line">        &quot;set&quot; : &quot;shopex&quot;,</div><div class="line">        &quot;date&quot; : ISODate(&quot;2015-07-04T01:30:29.593Z&quot;),</div><div class="line">        &quot;myState&quot; : 1,</div><div class="line">        &quot;members&quot; : [</div><div class="line">                &#123;</div><div class="line">                        &quot;_id&quot; : 1,</div><div class="line">                        &quot;name&quot; : &quot;127.0.0.1:2222&quot;,</div><div class="line">                        &quot;health&quot; : 1,</div><div class="line">                        &quot;state&quot; : 1,</div><div class="line">                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,</div><div class="line">                        &quot;uptime&quot; : 1492,</div><div class="line">                        &quot;optime&quot; : Timestamp(1435973390, 1),</div><div class="line">                        &quot;optimeDate&quot; : ISODate(&quot;2015-07-04T01:29:50Z&quot;),</div><div class="line">                        &quot;electionTime&quot; : Timestamp(1435972562, 2),</div><div class="line">                        &quot;electionDate&quot; : ISODate(&quot;2015-07-04T01:16:02Z&quot;),</div><div class="line">                        &quot;configVersion&quot; : 2,</div><div class="line">                        &quot;self&quot; : true</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                        &quot;_id&quot; : 2,</div><div class="line">                        &quot;name&quot; : &quot;127.0.0.1:3333&quot;,</div><div class="line">                        &quot;health&quot; : 1,</div><div class="line">                        &quot;state&quot; : 2,</div><div class="line">                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,</div><div class="line">                        &quot;uptime&quot; : 870,</div><div class="line">                        &quot;optime&quot; : Timestamp(1435973390, 1),</div><div class="line">                        &quot;optimeDate&quot; : ISODate(&quot;2015-07-04T01:29:50Z&quot;),</div><div class="line">                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-07-04T01:30:28.854Z&quot;),</div><div class="line">                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-07-04T01:30:29.147Z&quot;),</div><div class="line">                        &quot;pingMs&quot; : 0,</div><div class="line">                        &quot;syncingTo&quot; : &quot;127.0.0.1:2222&quot;,</div><div class="line">                        &quot;configVersion&quot; : 2</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                        &quot;_id&quot; : 3,</div><div class="line">                        &quot;name&quot; : &quot;127.0.0.1:4444&quot;,</div><div class="line">                        &quot;health&quot; : 1,</div><div class="line">                        &quot;state&quot; : 7,</div><div class="line">                        &quot;stateStr&quot; : &quot;ARBITER&quot;,</div><div class="line">                        &quot;uptime&quot; : 38,</div><div class="line">                        &quot;lastHeartbeat&quot; : ISODate(&quot;2015-07-04T01:30:28.855Z&quot;),</div><div class="line">                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-07-04T01:30:29.175Z&quot;),</div><div class="line">                        &quot;pingMs&quot; : 0,</div><div class="line">                        &quot;configVersion&quot; : 2</div><div class="line">                &#125;</div><div class="line">        ],</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的结果显示很清楚。</p>
<p>不是说该集群有自动故障恢复吗？那么我们就可以来试一下，在2222端口的cmd服务器按Ctrl+C来KO掉该服务器，立马我们发现在3333端口的从属服务器即可顶上，最后大家也可以再次使用rs.status()来看下集群中服务器的状态。</p>
<p>其它：</p>
<p>在从服务器是无法查看数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; use test;</div><div class="line">switched to db test</div><div class="line">&gt; db.user.find()</div><div class="line">Error: error: &#123; &quot;$err&quot; : &quot;not master and slaveOk=false&quot;, &quot;code&quot; : 13435 &#125;</div></pre></td></tr></table></figure></p>
<p>切换到主服务器就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">shopex:PRIMARY&gt; db.user.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;55935f703cb05382291e9132&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 22 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360ae3cb05382291e9134&quot;), &quot;name&quot; : &quot;hxc&quot;, &quot;birthday&quot; : &quot;1989-2-2&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360bd3cb05382291e9135&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360d13cb05382291e9136&quot;), &quot;name&quot; : &quot;joe&quot;, &quot;birthday&quot; : &quot;1989-2-22&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360df3cb05382291e9137&quot;), &quot;name&quot; : &quot;mary&quot;, &quot;birthday&quot; : &quot;1989-3-12&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;559360e93cb05382291e9138&quot;), &quot;name&quot; : &quot;jr&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5595f1500369349a9f73e947&quot;), &quot;name&quot; : &quot;mary&quot;, &quot;age&quot; : 23 &#125;</div><div class="line">shopex:PRIMARY&gt; db.user.insert(&#123;&quot;name&quot;:&quot;tt&quot;&#125;)</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">shopex:PRIMARY&gt;</div></pre></td></tr></table></figure></p>
<p>当然也可以使用下rs.slaveOk() 命令，使其可以查询数据（还是不能更新之类的）</p>
<p>拓展：<br>rs相关命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">shopex:PRIMARY&gt; rs.help()</div><div class="line">	rs.status()                           &#123; replSetGetStatus : 1 &#125; checks repl set status</div><div class="line">	rs.initiate()                         &#123; replSetInitiate : null &#125; initiates set with default settings</div><div class="line">	rs.initiate(cfg)                      &#123; replSetInitiate : cfg &#125; initiates set with configuration cfg</div><div class="line">	rs.conf()                             get the current configuration object from local.system.replset</div><div class="line">	rs.reconfig(cfg)                      updates the configuration of a running replica set with cfg (disconnects)</div><div class="line">	rs.add(hostportstr)                   add a new member to the set with default attributes (disconnects)</div><div class="line">	rs.add(membercfgobj)                  add a new member to the set with extra attributes (disconnects)</div><div class="line">	rs.addArb(hostportstr)                     add a new member which is arbiterOnly:true (disconnects)</div><div class="line">	rs.stepDown([stepdownSecs, catchUpSecs])   step down as primary (disconnects)</div><div class="line">	rs.syncFrom(hostportstr)              make a secondary sync from the given member</div><div class="line">	rs.freeze(secs)                       make a node ineligible to become primary for the time specified</div><div class="line">	rs.remove(hostportstr)                remove a host from the replica set (disconnects)</div><div class="line">	rs.slaveOk()                          allow queries on secondary nodes</div><div class="line"></div><div class="line">	rs.printReplicationInfo()             check oplog size and time range</div><div class="line">	rs.printSlaveReplicationInfo()        check replica set members and replication lag</div><div class="line">	db.isMaster()                         check who is primary</div><div class="line"></div><div class="line">	reconfiguration helpers disconnect from the database so the shell will display</div><div class="line">	an error, even if the command succeeds.</div></pre></td></tr></table></figure></p>
<p>后记：<br>    有些问题，关掉2222端口的服务器，3333和4444都提示：<br>couldn’t connect to server 127.0.0.1:2222(127.0.0.1)</p>
<p>然后再打开2222端口的服务器，现在3333的变成主服务器了。</p>
<p>再关掉3333提示， couldn’t connect to server 127.0.0.1:3333 (127.0.0.1)，且使用rs.status()显示3333的状态是 “stateStr” : “(not reachable/healthy)”</p>
<blockquote>
<p>参考：<br>8天学通MongoDB——第五天 主从复制 - 一线码农 - 博客园<br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/03/04/2379755.html" target="_blank" rel="external">http://www.cnblogs.com/huangxincheng/archive/2012/03/04/2379755.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h2&gt;&lt;p&gt;1.这种架构有如下的好处：&lt;br&gt; &lt;1&gt;  数据备份。&lt;br&gt; &lt;2&gt;  数据恢复。&lt;br&gt; &lt;3&gt;  读写分离。&lt;/3&gt;&lt;/2&gt;&lt;/1&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongo" scheme="http://52fhy.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB——第四天 索引操作</title>
    <link href="http://52fhy.github.io/2015/07/08/mongodb/MongoDB%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E5%A4%A9%20%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"/>
    <id>http://52fhy.github.io/2015/07/08/mongodb/MongoDB——第四天 索引操作/</id>
    <published>2015-07-08T01:55:00.000Z</published>
    <updated>2015-07-08T01:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>好，今天分享下mongodb中关于索引的基本操作，我们日常做开发都避免不了要对程序进行性能优化，而程序的操作无非就是CURD，通常我们又会花费50%的时间在R上面，因为Read操作对用户来说是非常敏感的，处理不好就会被人唾弃。</p>
<p>从算法上来说有5种经典的查找，具体的可以参见我的算法速成系列，这其中就包括我们今天所说的“索引查找”，如果大家对sqlserver比较了解的话，相信索引查找能给我们带来什么样的性能提升吧。</p>
<a id="more"></a>
<p>我们首先插入10w数据，上程序说话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.person.drop();//删除person集合</div><div class="line"></div><div class="line">//创建10W条数据</div><div class="line">for(var i=0; i&lt; 100000; i++)&#123;</div><div class="line">    db.user.insert(&#123;&quot;name&quot;:&quot;hxj&quot;+i, &quot;age&quot; : i&#125;);</div><div class="line">&#125;</div><div class="line">   </div><div class="line">&gt; db.user.count();</div><div class="line">100000</div></pre></td></tr></table></figure>
<p>已经有10W条数据了。</p>
<h2 id="性能分析函数（explain）"><a href="#性能分析函数（explain）" class="headerlink" title="性能分析函数（explain）"></a>性能分析函数（explain）</h2><p>好了，数据已经插入成功，既然我们要做分析，肯定要有分析的工具，幸好mongodb中给我们提供了一个关键字叫做“explain”，那么怎么用呢？</p>
<p>还是看程序，注意，这里的name字段没有建立任何索引，这里我就查询一个“name10000”的姓名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.find(&#123;&quot;name&quot; : &quot;hxj&quot;+10000&#125;);</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;55935a673cb05382291d31a0&quot;), &quot;name&quot; : &quot;hxj10000&quot;, &quot;age&quot; : 10000 &#125;</div><div class="line"></div><div class="line">&gt; db.user.find(&#123;&quot;name&quot; : &quot;hxj&quot;+10000&#125;).explain();</div><div class="line">&#123;</div><div class="line">        &quot;queryPlanner&quot; : &#123;</div><div class="line">                &quot;plannerVersion&quot; : 1,</div><div class="line">                &quot;namespace&quot; : &quot;test.user&quot;,</div><div class="line">                &quot;indexFilterSet&quot; : false,</div><div class="line">                &quot;parsedQuery&quot; : &#123;</div><div class="line">                        &quot;name&quot; : &#123;</div><div class="line">                                &quot;$eq&quot; : &quot;hxj10000&quot;</div><div class="line">                        &#125;</div><div class="line">                &#125;,</div><div class="line">                &quot;winningPlan&quot; : &#123;</div><div class="line">                        &quot;stage&quot; : &quot;COLLSCAN&quot;,</div><div class="line">                        &quot;filter&quot; : &#123;</div><div class="line">                                &quot;name&quot; : &#123;</div><div class="line">                                        &quot;$eq&quot; : &quot;hxj10000&quot;</div><div class="line">                                &#125;</div><div class="line">                        &#125;,</div><div class="line">                        &quot;direction&quot; : &quot;forward&quot;</div><div class="line">                &#125;,</div><div class="line">                &quot;rejectedPlans&quot; : [ ]</div><div class="line">        &#125;,</div><div class="line">        &quot;serverInfo&quot; : &#123;</div><div class="line">                &quot;host&quot; : &quot;YJC-PC&quot;,</div><div class="line">                &quot;port&quot; : 27017,</div><div class="line">                &quot;version&quot; : &quot;3.0.4&quot;,</div><div class="line">                &quot;gitVersion&quot; : &quot;0481c958daeb2969800511e7475dc66986fa9ed5&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;stage&quot; : &quot;COLLSCAN&quot;,</div></pre></td></tr></table></figure></p>
<p><code>stage</code> 是<code>COLLSCAN</code>，说明没有走索引，走索引的话会显示<code>IXSCAN</code>。</p>
<p>基于mongo3.0，和2.x的版本有些地方会不大一样。</p>
<p>旧版的话，会有几个Key可以看下：<br>   <code>cursor</code>: 如果出现的是<code>BasicCursor</code>，就是说这里的查找采用的是“表扫描”，也就是顺序查找，很悲催啊。<br>   <code>nscanned</code>:表示数据库浏览了多少个文档。<br>   <code>n</code>: 最终返回了多少个文档。<br>   <code>millis</code>:总共耗时多少毫秒。 </p>
<h2 id="建立索引（ensureIndex）"><a href="#建立索引（ensureIndex）" class="headerlink" title="建立索引（ensureIndex）"></a>建立索引（ensureIndex）</h2><p>在10w条这么简单的集合中查找一个文档要114毫秒有一点点让人不能接收（2.x版本），好，那么我们该如何优化呢？mongodb中给我们带来了索引查找，看看能不能让我们的查询一飞冲天…..</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.ensureIndex(&#123;&quot;name&quot;:1&#125;);</div><div class="line">&#123;</div><div class="line">        &quot;createdCollectionAutomatically&quot; : false,</div><div class="line">        &quot;numIndexesBefore&quot; : 1,</div><div class="line">        &quot;numIndexesAfter&quot; : 2,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">&gt; db.user.find(&#123;&quot;name&quot; : &quot;hxj&quot;+10000&#125;).explain();</div><div class="line">&#123;</div><div class="line">        &quot;queryPlanner&quot; : &#123;</div><div class="line">                &quot;plannerVersion&quot; : 1,</div><div class="line">                &quot;namespace&quot; : &quot;test.user&quot;,</div><div class="line">                &quot;indexFilterSet&quot; : false,</div><div class="line">                &quot;parsedQuery&quot; : &#123;</div><div class="line">                        &quot;name&quot; : &#123;</div><div class="line">                                &quot;$eq&quot; : &quot;hxj10000&quot;</div><div class="line">                        &#125;</div><div class="line">                &#125;,</div><div class="line">                &quot;winningPlan&quot; : &#123;</div><div class="line">                        &quot;stage&quot; : &quot;FETCH&quot;,</div><div class="line">                        &quot;inputStage&quot; : &#123;</div><div class="line">                                &quot;stage&quot; : &quot;IXSCAN&quot;,</div><div class="line">                                &quot;keyPattern&quot; : &#123;</div><div class="line">                                        &quot;name&quot; : 1</div><div class="line">                                &#125;,</div><div class="line">                                &quot;indexName&quot; : &quot;name_1&quot;,</div><div class="line">                                &quot;isMultiKey&quot; : false,</div><div class="line">                                &quot;direction&quot; : &quot;forward&quot;,</div><div class="line">                                &quot;indexBounds&quot; : &#123;</div><div class="line">                                        &quot;name&quot; : [</div><div class="line">                                                &quot;[\&quot;hxj10000\&quot;, \&quot;hxj10000\&quot;]&quot;</div><div class="line">                                        ]</div><div class="line">                                &#125;</div><div class="line">                        &#125;</div><div class="line">                &#125;,</div><div class="line">                &quot;rejectedPlans&quot; : [ ]</div><div class="line">        &#125;,</div><div class="line">        &quot;serverInfo&quot; : &#123;</div><div class="line">                &quot;host&quot; : &quot;YJC-PC&quot;,</div><div class="line">                &quot;port&quot; : 27017,</div><div class="line">                &quot;version&quot; : &quot;3.0.4&quot;,</div><div class="line">                &quot;gitVersion&quot; : &quot;0481c958daeb2969800511e7475dc66986fa9ed5&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们使用了ensureIndex在name上建立了索引。<br><code>1</code>：表示按照name进行升序，<code>-1</code>：表示按照name进行降序。</p>
<p>这回<code>stage</code> 是<code>FETCH</code>。</p>
<p>如果是2.x版本，会有这些信息：<br>   <code>cursor</code>: 如果是<code>BtreeCursor</code>，这么牛X，mongodb采用B树的结构来存放索引，索引名为后面的“name_1”。<br>   <code>nscanned</code>:表示数据库浏览了多少个文档。<br>   <code>n</code>: 最终返回了多少个文档。<br>   <code>millis</code>:总共耗时多少毫秒。 </p>
<p>通过这个例子相信大家对索引也有了感官方面的认识了吧。</p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>和sqlserver一样都可以建立唯一索引，重复的键值自然就不能插入，在mongodb中的使用方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">db.user.ensureIndex(&#123;&quot;name&quot;:1&#125;,&#123;&quot;unique&quot;:true&#125;)</div><div class="line"></div><div class="line">/*删除所有数据，发现删除不了*/</div><div class="line">&gt; db.user.remove()</div><div class="line">2015-07-01T11:29:38.579+0800 E QUERY    Error: remove needs a query</div><div class="line">    at Error (&lt;anonymous&gt;)</div><div class="line">    at DBCollection._parseRemove (src/mongo/shell/collection.js:305:32)</div><div class="line">    at DBCollection.remove (src/mongo/shell/collection.js:328:23)</div><div class="line">    at (shell):1:9 at src/mongo/shell/collection.js:305</div><div class="line">    </div><div class="line">/*删除所有数据*/</div><div class="line">&gt; db.user.remove(&#123;&#125;)</div><div class="line">WriteResult(&#123; &quot;nRemoved&quot; : 100000 &#125;)</div><div class="line"></div><div class="line">&gt; db.user.ensureIndex(&#123;&quot;name&quot;:1&#125;, &#123;&quot;unique&quot;: true&#125;);</div><div class="line">&#123;</div><div class="line">        &quot;createdCollectionAutomatically&quot; : false,</div><div class="line">        &quot;numIndexesBefore&quot; : 2,</div><div class="line">        &quot;errmsg&quot; : &quot;exception: Index with name: name_1 already exists with different options&quot;,</div><div class="line">        &quot;code&quot; : 85,</div><div class="line">        &quot;ok&quot; : 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">&gt; db.user.count()</div><div class="line">0</div><div class="line"></div><div class="line">/*清空集合里数据*/</div><div class="line">&gt; db.user.drop()</div><div class="line">true</div><div class="line">&gt; db.user.ensureIndex(&#123;&quot;name&quot;:1&#125;, &#123;&quot;unique&quot;: true&#125;);</div><div class="line">&#123;</div><div class="line">        &quot;createdCollectionAutomatically&quot; : true,</div><div class="line">        &quot;numIndexesBefore&quot; : 1,</div><div class="line">        &quot;numIndexesAfter&quot; : 2,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">&gt; db.user.insert(&#123;&quot;name&quot;:&quot;yjc&quot;, &quot;age&quot;: 22&#125;);</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line"></div><div class="line">&gt; db.user.insert(&#123;&quot;name&quot;:&quot;yjc&quot;, &quot;age&quot;: 23&#125;);</div><div class="line">WriteResult(&#123;</div><div class="line">        &quot;nInserted&quot; : 0,</div><div class="line">        &quot;writeError&quot; : &#123;</div><div class="line">                &quot;code&quot; : 11000,</div><div class="line">                &quot;errmsg&quot; : &quot;E11000 duplicate key error index: test.user.$name_1 dup key: &#123; : \&quot;yjc\&quot; &#125;&quot;</div><div class="line">        &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>有时候我们的查询不是单条件的，可能是多条件，比如查找出生在‘1989-3-2’名字叫‘jack’的同学，那么我们可以建立“姓名”和”生日“的联合索引来加速查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.insert(&#123;&quot;name&quot; : &quot;hxc&quot;, &quot;birthday&quot; : &quot;1989-2-2&quot;&#125;);</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.user.insert(&#123;&quot;name&quot; : &quot;jack&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot;&#125;);</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.user.insert(&#123;&quot;name&quot; : &quot;joe&quot;, &quot;birthday&quot; : &quot;1989-2-22&quot;&#125;);</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.user.insert(&#123;&quot;name&quot; : &quot;mary&quot;, &quot;birthday&quot; : &quot;1989-3-12&quot;&#125;);</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line">&gt; db.user.insert(&#123;&quot;name&quot; : &quot;jr&quot;, &quot;birthday&quot; : &quot;1989-3-2&quot;&#125;);</div><div class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</div><div class="line"></div><div class="line">&gt; db.user.ensureIndex(&#123;&quot;name&quot;:1, &quot;birthday&quot;:1&#125;)</div><div class="line">&#123;</div><div class="line">        &quot;createdCollectionAutomatically&quot; : false,</div><div class="line">        &quot;numIndexesBefore&quot; : 2,</div><div class="line">        &quot;numIndexesAfter&quot; : 3,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">&gt; db.user.ensureIndex(&#123;&quot;birthday&quot;:1, &quot;name&quot;:1&#125;)</div><div class="line">&#123;</div><div class="line">        &quot;createdCollectionAutomatically&quot; : false,</div><div class="line">        &quot;numIndexesBefore&quot; : 3,</div><div class="line">        &quot;numIndexesAfter&quot; : 4,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到上面，大家或者也知道name跟birthday的不同，建立的索引也不同，升序和降序的顺序不同都会产生不同的索引，那么我们可以用getindexes来查看下person集合中到底生成了那些索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.getIndexes()</div><div class="line">[</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;_id&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;_id_&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;unique&quot; : true,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;name&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;name_1&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;name&quot; : 1,</div><div class="line">                        &quot;birthday&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;name_1_birthday_1&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;birthday&quot; : 1,</div><div class="line">                        &quot;name&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;birthday_1_name_1&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>此时我们肯定很好奇，到底查询优化器会使用哪个查询作为操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.find(&#123;&quot;name&quot;:&quot;jack&quot;, &quot;birthday&quot;:&quot;1989-3-2&quot;&#125;).explain();</div><div class="line">&#123;</div><div class="line">        &quot;queryPlanner&quot; : &#123;</div><div class="line">                &quot;plannerVersion&quot; : 1,</div><div class="line">                &quot;namespace&quot; : &quot;test.user&quot;,</div><div class="line">                &quot;indexFilterSet&quot; : false,</div><div class="line">                &quot;parsedQuery&quot; : &#123;</div><div class="line">                        &quot;$and&quot; : [</div><div class="line">                                &#123;</div><div class="line">                                        &quot;birthday&quot; : &#123;</div><div class="line">                                                &quot;$eq&quot; : &quot;1989-3-2&quot;</div><div class="line">                                        &#125;</div><div class="line">                                &#125;,</div><div class="line">                                &#123;</div><div class="line">                                        &quot;name&quot; : &#123;</div><div class="line">                                                &quot;$eq&quot; : &quot;jack&quot;</div><div class="line">                                        &#125;</div><div class="line">                                &#125;</div><div class="line">                        ]</div><div class="line">                &#125;,</div><div class="line">                &quot;winningPlan&quot; : &#123;</div><div class="line">                        &quot;stage&quot; : &quot;KEEP_MUTATIONS&quot;,</div><div class="line">                        &quot;inputStage&quot; : &#123;</div><div class="line">                                &quot;stage&quot; : &quot;FETCH&quot;,</div><div class="line">                                &quot;filter&quot; : &#123;</div><div class="line">                                        &quot;birthday&quot; : &#123;</div><div class="line">                                                &quot;$eq&quot; : &quot;1989-3-2&quot;</div><div class="line">                                        &#125;</div><div class="line">                                &#125;,</div><div class="line">                                &quot;inputStage&quot; : &#123;</div><div class="line">                                        &quot;stage&quot; : &quot;IXSCAN&quot;,</div><div class="line">                                        &quot;keyPattern&quot; : &#123;</div><div class="line">                                                &quot;name&quot; : 1</div><div class="line">                                        &#125;,</div><div class="line">                                        &quot;indexName&quot; : &quot;name_1&quot;,</div><div class="line">                                        &quot;isMultiKey&quot; : false,</div><div class="line">                                        &quot;direction&quot; : &quot;forward&quot;,</div><div class="line">                                        &quot;indexBounds&quot; : &#123;</div><div class="line">                                                &quot;name&quot; : [</div><div class="line">                                                        &quot;[\&quot;jack\&quot;, \&quot;jack\&quot;]&quot;</div><div class="line">                                                ]</div><div class="line">                                        &#125;</div><div class="line">                                &#125;</div><div class="line">                        &#125;</div><div class="line">                &#125;,</div><div class="line">                &quot;rejectedPlans&quot; : [ ]</div><div class="line">        &#125;,</div><div class="line">        &quot;serverInfo&quot; : &#123;</div><div class="line">                &quot;host&quot; : &quot;YJC-PC&quot;,</div><div class="line">                &quot;port&quot; : 27017,</div><div class="line">                &quot;version&quot; : &quot;3.0.4&quot;,</div><div class="line">                &quot;gitVersion&quot; : &quot;0481c958daeb2969800511e7475dc66986fa9ed5&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到结果我们要相信查询优化器，它给我们做出的选择往往是最优的，因为我们做查询时，查询优化器会使用我们建立的这些索引来创建查询方案，如果某一个先执行完则其他查询方案被close掉，这种方案会被mongodb保存起来，当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了hint方法让我们可以暴力执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.find(&#123;&quot;name&quot;:&quot;jack&quot;, &quot;birthday&quot;:&quot;1989-3-2&quot;&#125;).hint(&#123;&quot;birthday&quot;:1, &quot;name&quot;:1&#125;).explain();</div><div class="line">&#123;</div><div class="line">        &quot;queryPlanner&quot; : &#123;</div><div class="line">                &quot;plannerVersion&quot; : 1,</div><div class="line">                &quot;namespace&quot; : &quot;test.user&quot;,</div><div class="line">                &quot;indexFilterSet&quot; : false,</div><div class="line">                &quot;parsedQuery&quot; : &#123;</div><div class="line">                        &quot;$and&quot; : [</div><div class="line">                                &#123;</div><div class="line">                                        &quot;birthday&quot; : &#123;</div><div class="line">                                                &quot;$eq&quot; : &quot;1989-3-2&quot;</div><div class="line">                                        &#125;</div><div class="line">                                &#125;,</div><div class="line">                                &#123;</div><div class="line">                                        &quot;name&quot; : &#123;</div><div class="line">                                                &quot;$eq&quot; : &quot;jack&quot;</div><div class="line">                                        &#125;</div><div class="line">                                &#125;</div><div class="line">                        ]</div><div class="line">                &#125;,</div><div class="line">                &quot;winningPlan&quot; : &#123;</div><div class="line">                        &quot;stage&quot; : &quot;FETCH&quot;,</div><div class="line">                        &quot;inputStage&quot; : &#123;</div><div class="line">                                &quot;stage&quot; : &quot;IXSCAN&quot;,</div><div class="line">                                &quot;keyPattern&quot; : &#123;</div><div class="line">                                        &quot;birthday&quot; : 1,</div><div class="line">                                        &quot;name&quot; : 1</div><div class="line">                                &#125;,</div><div class="line">                                &quot;indexName&quot; : &quot;birthday_1_name_1&quot;,</div><div class="line">                                &quot;isMultiKey&quot; : false,</div><div class="line">                                &quot;direction&quot; : &quot;forward&quot;,</div><div class="line">                                &quot;indexBounds&quot; : &#123;</div><div class="line">                                        &quot;birthday&quot; : [</div><div class="line">                                                &quot;[\&quot;1989-3-2\&quot;, \&quot;1989-3-2\&quot;]&quot;</div><div class="line">                                        ],</div><div class="line">                                        &quot;name&quot; : [</div><div class="line">                                                &quot;[\&quot;jack\&quot;, \&quot;jack\&quot;]&quot;</div><div class="line">                                        ]</div><div class="line">                                &#125;</div><div class="line">                        &#125;</div><div class="line">                &#125;,</div><div class="line">                &quot;rejectedPlans&quot; : [ ]</div><div class="line">        &#125;,</div><div class="line">        &quot;serverInfo&quot; : &#123;</div><div class="line">                &quot;host&quot; : &quot;YJC-PC&quot;,</div><div class="line">                &quot;port&quot; : 27017,</div><div class="line">                &quot;version&quot; : &quot;3.0.4&quot;,</div><div class="line">                &quot;gitVersion&quot; : &quot;0481c958daeb2969800511e7475dc66986fa9ed5&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>可能随着业务需求的变化，原先建立的索引可能没有存在的必要了，可能有的人想说没必要就没必要呗，但是请记住，索引会降低CUD这三种操作的性能，因为这玩意需要实时维护，所以啥问题都要综合考虑一下，这里就把刚才建立的索引清空掉来演示一下:dropIndex的使用。</p>
<p>dropIndex()删除某个索引<br>dropIndexes()删除全部索引</p>
<p>先查看索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.getIndexes()</div><div class="line">[</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;_id&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;_id_&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;name&quot; : 1,</div><div class="line">                        &quot;birthday&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;name_1_birthday_1&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;name&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;name_1&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;name&quot; : 1,</div><div class="line">                        &quot;unique&quot; : true</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;name_1_unique_true&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>删除普通索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.dropIndex(&quot;name_1&quot;);</div><div class="line">&#123; &quot;nIndexesWas&quot; : 4, &quot;ok&quot; : 1 &#125;</div></pre></td></tr></table></figure></p>
<p>删除全部索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.dropIndexes();</div><div class="line">&#123;</div><div class="line">        &quot;nIndexesWas&quot; : 3,</div><div class="line">        &quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看还有什么索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.getIndexes()</div><div class="line">[</div><div class="line">        &#123;</div><div class="line">                &quot;v&quot; : 1,</div><div class="line">                &quot;key&quot; : &#123;</div><div class="line">                        &quot;_id&quot; : 1</div><div class="line">                &#125;,</div><div class="line">                &quot;name&quot; : &quot;_id_&quot;,</div><div class="line">                &quot;ns&quot; : &quot;test.user&quot;</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>参考：<br>8天学通MongoDB——第四天 索引操作 - 一线码农 - 博客园<br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/02/29/2372699.html" target="_blank" rel="external">http://www.cnblogs.com/huangxincheng/archive/2012/02/29/2372699.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好，今天分享下mongodb中关于索引的基本操作，我们日常做开发都避免不了要对程序进行性能优化，而程序的操作无非就是CURD，通常我们又会花费50%的时间在R上面，因为Read操作对用户来说是非常敏感的，处理不好就会被人唾弃。&lt;/p&gt;
&lt;p&gt;从算法上来说有5种经典的查找，具体的可以参见我的算法速成系列，这其中就包括我们今天所说的“索引查找”，如果大家对sqlserver比较了解的话，相信索引查找能给我们带来什么样的性能提升吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongo" scheme="http://52fhy.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>第2讲 Redis常用命令与高级应用</title>
    <link href="http://52fhy.github.io/2015/07/07/redis/2_Redis_common_commands_and_advanced_applications/"/>
    <id>http://52fhy.github.io/2015/07/07/redis/2_Redis_common_commands_and_advanced_applications/</id>
    <published>2015-07-07T05:52:29.000Z</published>
    <updated>2018-12-30T04:26:47.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、redis数据类型"><a href="#一、redis数据类型" class="headerlink" title="一、redis数据类型"></a>一、redis数据类型</h2><h3 id="5-sorted-sets类型和操作"><a href="#5-sorted-sets类型和操作" class="headerlink" title="5. sorted sets类型和操作"></a>5. sorted sets类型和操作</h3><blockquote>
<p>sorted set是set的一个升级版本，它给集合中每个元素都定义一个分数，集合中的元素按照其分数排序。</p>
</blockquote>
<a id="more"></a>
<p>1） zadd  键  分数1  值1  [分数2  值2…]<br>    该命令添加指定的成员到key对应的有序集合中，每个成员都有一个分数。你可以指定多个分数/成员组合。如果一个指定的成员已经在对应的有序集合中了，那么其分数就会被更新成最新的，并且该成员会重新调整到正确的位置，以确保集合有序。分数的值必须是一个表示数字的字符串，并且可以是double类型的浮点数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zadd zset1 1 lm 2 sc 3 glf</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt;zadd zset1 1 ymj</div><div class="line">(integer) 1</div></pre></td></tr></table></figure></p>
<p>2） zrange  集合  起始下标  截止下标  [withscores]<br>    返回有序集合中，指定区间内的成员。其中成员按照score（分数）值从小到大排序。具有相同score值的成员按照字典顺序来排列。</p>
<pre><code>起始下标与截止下标和list类型一致：
    0代表队列中第一个元素，1代表第二个元素，依次类推
    -1代表队列中最后一个元素，-2代表倒数第二个元素

withscores：返回集合中元素的同时，返回其分数（score）
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrange zset1 0 -1 withscores</div><div class="line">1) &quot;lm&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;ymj&quot;</div><div class="line">4) &quot;1&quot;</div><div class="line">5) &quot;sc&quot;</div><div class="line">6) &quot;2&quot;</div><div class="line">7) &quot;glf&quot;</div><div class="line">8) &quot;3&quot;</div></pre></td></tr></table></figure>
<p>3） zrevrange  集合  起始下标  截止下标  [withscores]<br>    返回有序集合中，指定区间的成员。其成员按照score从大到小来排列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrevrange zset1 0 -1 withscores</div><div class="line">1) &quot;glf&quot;		//下标为0</div><div class="line">2) &quot;3&quot;</div><div class="line">3) &quot;sc&quot;			//下标为1</div><div class="line">4) &quot;2&quot;</div><div class="line">5) &quot;ymj&quot;		//下标为2</div><div class="line">6) &quot;1&quot;</div><div class="line">7) &quot;lm&quot;			//下标为3</div><div class="line">8) &quot;1&quot;</div><div class="line"></div><div class="line">127.0.0.1:6379&gt;zrevrange zset1 1 2 withscores		//查看集合中下标是1-2的值</div><div class="line">1) &quot;sc&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;ymj&quot;</div><div class="line">4) &quot;1&quot;</div></pre></td></tr></table></figure></p>
<p>4） zrangebyscore  集合  起始分数  截止分数  withscores(不包含截止分数)<br>    返回有序集合中score（分数）在指定区间的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zadd zset2 1 one 2 two 3 three 4 four</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt;zrange zset2 0 -1 withscores		//按照下标区间返回值</div><div class="line">1) &quot;one&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;two&quot;</div><div class="line">4) &quot;2&quot;</div><div class="line">5) &quot;three&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line">7) &quot;four&quot;</div><div class="line">8) &quot;4&quot;</div><div class="line"></div><div class="line">127.0.0.1:6379&gt;zrangebyscore zset2 2 3 withscores	//按照分数区间返回值</div><div class="line">1) &quot;two&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;three&quot;</div><div class="line">4) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<p>5） zrem  集合  值1  [值2…]<br>    删除有序集合中指定的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrem zset1 lm</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;zrange zset1 0 -1 withscores</div><div class="line">1) &quot;ymj&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;sc&quot;</div><div class="line">4) &quot;2&quot;</div><div class="line">5) &quot;glf&quot;</div><div class="line">6) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<p>6） zincrby  集合  增量  值<br>    给有序集合中指定值的成员的分数（score）值加上增量（increment）。如果集合中没有这个值，则给添加一个分数是increment的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zincrby zset1 2 ymj		//如果值存在，则在其分数上加增量</div><div class="line">&quot;3&quot;</div><div class="line">127.0.0.1:6379&gt;zrange zset1 0 -1 withscores</div><div class="line">1) &quot;sc&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;glf&quot;</div><div class="line">4) &quot;3&quot;</div><div class="line">5) &quot;ymj&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line"></div><div class="line">127.0.0.1:6379&gt;zincrby zset1 4 bro		//如果值不存在，则加入值。并指定分数为增&quot;4&quot;										量</div><div class="line"></div><div class="line">127.0.0.1:6379&gt;zrange zset1 0 -1 withscores</div><div class="line">1) &quot;sc&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;glf&quot;</div><div class="line">4) &quot;3&quot;</div><div class="line">5) &quot;ymj&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line">7) &quot;bro&quot;</div><div class="line">8) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>7） zrank  集合  值<br>    返回有序集合中指定值的下标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrank zset1 sc</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt;zrank zset1 ymj</div><div class="line">(integer) 2</div></pre></td></tr></table></figure></p>
<p>8） zrevrank  集合  值<br>    返回有序集合中指定值的下标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrange zset1 0 -1 withscores</div><div class="line">1) &quot;sc&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;glf&quot;</div><div class="line">4) &quot;3&quot;</div><div class="line">5) &quot;ymj&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line">7) &quot;bro&quot;</div><div class="line">8) &quot;4&quot;</div><div class="line">127.0.0.1:6379&gt;zrevrank zset1 ymj</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;zrevrank zset1 sc</div><div class="line">(integer) 3</div></pre></td></tr></table></figure></p>
<p>9） zcount  集合  起始分数  截止分数<br>    返回有序集合中，score值在起始分数与截止分数之间的个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrange zset2 0 -1 withscores</div><div class="line">1) &quot;one&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;two&quot;</div><div class="line">4) &quot;2&quot;</div><div class="line">5) &quot;three&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line">7) &quot;four&quot;</div><div class="line">8) &quot;4&quot;</div><div class="line"></div><div class="line">127.0.0.1:6379&gt;zcount zset2 2 4</div><div class="line">(integer) 3</div></pre></td></tr></table></figure></p>
<p>10） zcard  集合<br>    返回有序集合元素的个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zcard zset2</div><div class="line">(integer) 4</div></pre></td></tr></table></figure></p>
<p>11） zremrangebyrank  集合  起始下标  结束下标<br>    删除有序集合中，下标在指定区间的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrange zset2 0 -1 withscores</div><div class="line">1) &quot;one&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;two&quot;</div><div class="line">4) &quot;2&quot;</div><div class="line">5) &quot;three&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line">7) &quot;four&quot;</div><div class="line">8) &quot;4&quot;</div><div class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK zset2 0 1</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt;zrange zset2 0 -1 withscores</div><div class="line">1) &quot;three&quot;</div><div class="line">2) &quot;3&quot;</div><div class="line">3) &quot;four&quot;</div><div class="line">4) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>12） zremrangebyscore  集合  起始分数  截止分数<br>    删除有序集合中，分数在指定区间的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zrange zset1 0 -1 withscores</div><div class="line">1) &quot;sc&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;glf&quot;</div><div class="line">4) &quot;3&quot;</div><div class="line">5) &quot;ymj&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line">7) &quot;bro&quot;</div><div class="line">8) &quot;4&quot;</div><div class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE zset1 2 3 </div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt;zrange zset1 0 -1 withscores</div><div class="line">1) &quot;bro&quot;</div><div class="line">2) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>13）zinterstore  新集合  取交集的集合个数  集合1 集合2<br>    取集合1和集合2的交集，并把结果保存到新集合中。在计算交集之前，需要指定计算交集的集合的个数。交集中，值的分数是多个集合中分数的和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zadd zset1 1 one 2 two 3 three 4 four</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt;zaddzset2  2 two 3 three 4 four 5 five</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt; ZINTERSTORE zset3 2 zset1 zset2 	</div><div class="line">//有两个集合计算交集，所以集合个数是2</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt; ZRANGE zset3 0 -1 withscores</div><div class="line">1) &quot;two&quot;</div><div class="line">2) &quot;4&quot;				//分数是两个集合中two值的分数和</div><div class="line">3) &quot;three&quot;</div><div class="line">4) &quot;6&quot;</div><div class="line">5) &quot;four&quot;</div><div class="line">6) &quot;8&quot;</div></pre></td></tr></table></figure></p>
<p>14） zunionstore  新集合  取并集的集合个数  集合1 集合2<br>    取集合1和集合2的并集，并把结果保存到新集合中。在计算并集之前，需要指定计算并集的集合的个数。并集中，值的分数是多个集合中分数的和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;zadd zset1 1 one 2 two 3 three 4 four</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt;zaddzset2  2 two 3 three 4 four 5 five</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt; ZUNIONSTORE zset4 2 zset1 zset2</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt; ZRANGE zset4 0 -1 withscores</div><div class="line"> 1) &quot;one&quot;</div><div class="line"> 2) &quot;1&quot;</div><div class="line"> 3) &quot;two&quot;</div><div class="line"> 4) &quot;4&quot;</div><div class="line"> 5) &quot;five&quot;</div><div class="line"> 6) &quot;5&quot;</div><div class="line"> 7) &quot;three&quot;</div><div class="line"> 8) &quot;6&quot;</div><div class="line"> 9) &quot;four&quot;</div><div class="line">10) &quot;8&quot;</div></pre></td></tr></table></figure></p>
<h2 id="二、Redis常用命令"><a href="#二、Redis常用命令" class="headerlink" title="二、Redis常用命令"></a>二、Redis常用命令</h2><h3 id="（一）-键值相关命令"><a href="#（一）-键值相关命令" class="headerlink" title="（一） 键值相关命令"></a>（一） 键值相关命令</h3><p>1、 keys  键名<br>    按照键名查找指定的键。支持通配符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set hello 1</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set hallo 1</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; set heeeello 1</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; keys h?llo</div><div class="line">1) &quot;hallo&quot;</div><div class="line">2) &quot;hello&quot;</div><div class="line">127.0.0.1:6379&gt; keys h*llo</div><div class="line">1) &quot;hallo&quot;</div><div class="line">2) &quot;heeeello&quot;</div><div class="line">3) &quot;hello&quot;</div></pre></td></tr></table></figure></p>
<p>2、    exists  键名<br>    确认一个键是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; EXISTS name</div><div class="line">(integer) 1						//name键存在</div><div class="line">127.0.0.1:6379&gt; EXISTS age</div><div class="line">(integer) 0						//age键不存在</div></pre></td></tr></table></figure></p>
<p>3、    del  键名<br>    删除一个键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;del hello</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; EXISTS hello</div><div class="line">(integer) 0</div></pre></td></tr></table></figure></p>
<p>4、    expire  键  秒<br>    设置一个键的过期时间，如果键已经过期，将会被自动删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set age 18</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; EXPIRE age 20</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;ttl age</div><div class="line">(integer) 18</div><div class="line">127.0.0.1:6379&gt;ttl age</div><div class="line">(integer) -2</div><div class="line">127.0.0.1:6379&gt; EXISTS age</div><div class="line">(integer) 0</div></pre></td></tr></table></figure></p>
<p>5、    ttl  键<br>    以秒为单位，返回键的剩余生存时间。<br>    当键不存在时，返回值为-2<br>    当键存在，但没有设置剩余生存时间时，返回-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;ttl name</div><div class="line">(integer) -1</div></pre></td></tr></table></figure></p>
<p>6、    select  数据库号<br>    选择一个数据库。<br>    默认连接的数据库是0，可以支持共16个数据库。<br>    在配置文件中，通过databases 16 关键字定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; select 1</div><div class="line">OK</div><div class="line">127.0.0.1:6379[1]&gt;</div></pre></td></tr></table></figure></p>
<p>7、    move  键  数据库号<br>    将当前数据库的键移动到指定的数据空中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set age 18</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; move age 1</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; get age</div><div class="line">(nil)</div><div class="line">127.0.0.1:6379&gt; select 1</div><div class="line">OK</div><div class="line">127.0.0.1:6379[1]&gt; get age</div><div class="line">&quot;18&quot;</div></pre></td></tr></table></figure></p>
<p>8、    randomkey<br>    从当前数据库返回一个随机的键。如果当前库没有任何键，则返回nil</p>
<p>9、    rename  旧名  新名<br>    重命名键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; rename name name_new</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; get name_new</div><div class="line">&quot;sc&quot;</div></pre></td></tr></table></figure></p>
<p>10、 type  键<br>    返回键类型。</p>
<blockquote>
<p>返回值<br>none (key不存在)<br>string (字符串)<br>list (列表)<br>set (集合)<br>zset (有序集)<br>hash (哈希表)</p>
</blockquote>
<h3 id="（二）-服务器相关命令"><a href="#（二）-服务器相关命令" class="headerlink" title="（二） 服务器相关命令"></a>（二） 服务器相关命令</h3><p>1、    ping<br>    测试服务器是否可以连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; ping</div><div class="line">PONG					//连接正常</div><div class="line">127.0.0.1:6379&gt; ping</div><div class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</div><div class="line">//redis被停止，连接拒绝</div></pre></td></tr></table></figure></p>
<p>2、    echo  字符串<br>    在命令行输出字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; echo &quot;test message&quot;</div><div class="line">&quot;test message&quot;</div></pre></td></tr></table></figure></p>
<p>3、    quit<br>    退出redis数据库</p>
<p>4、    save<br>    保存所有的数据。很少在生产环境直接使用SAVE 命令，因为它会阻塞所有的客户端的请求，可以使用<code>BGSAVE</code>命令代替. 如果在<code>BGSAVE</code>命令的保存数据的子进程发生错误的时,用<code>SAVE</code>命令保存最新的数据是最后的手段</p>
<p>5、    dbsize<br>    返回当前库中键的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;dbsize</div><div class="line">(integer) 6</div></pre></td></tr></table></figure></p>
<p>6、    info<br>    获取服务器的详细信息</p>
<p>7、    config get 参数<br>    获取redis服务器配置文件中的参数。支持通配符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;config get *			//查询配置文件中所有的参数</div><div class="line"> 1) &quot;dbfilename&quot;</div><div class="line"> 2) &quot;dump.rdb&quot;</div><div class="line">45) &quot;port&quot;</div><div class="line">46) &quot;6379&quot;</div><div class="line">99) &quot;save&quot;</div><div class="line">100) &quot;900 1 300 10 60 10000&quot;</div></pre></td></tr></table></figure></p>
<p>8、 flushdb<br>    删除当前数据库中所有的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;dbsize</div><div class="line">(integer) 6</div><div class="line">127.0.0.1:6379&gt;flushdb</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;dbsize</div><div class="line">(integer) 0</div></pre></td></tr></table></figure></p>
<p>9、    flushall<br>    删除所有数据库中所有的数据</p>
<h2 id="三、-redis高级应用"><a href="#三、-redis高级应用" class="headerlink" title="三、 redis高级应用"></a>三、 redis高级应用</h2><h3 id="1、-给redis服务器设置密码"><a href="#1、-给redis服务器设置密码" class="headerlink" title="1、    给redis服务器设置密码"></a>1、    给redis服务器设置密码</h3><p>1）修改redis服务器的配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# vi /usr/local/redis/etc/redis.conf</div><div class="line"># requirepass foobared					（大概391行）</div><div class="line">#找到这句话，requirepass后面就是登录redis的密码，改为自定义密码</div><div class="line">requirepass flzx_3QC</div></pre></td></tr></table></figure></p>
<p>2）重启redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# pkill redis</div><div class="line">[root@localhostredis]#/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</div></pre></td></tr></table></figure></p>
<p>3）连接redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# /usr/local/redis/bin/redis-cli </div><div class="line">127.0.0.1:6379&gt; keys *						//可以正常连接redis</div><div class="line">(error) NOAUTH Authentication required.		//但因为没有密码，提示操作拒绝</div><div class="line"></div><div class="line">127.0.0.1:6379&gt;auth flzx_3QC				//利用auth命令输入密码</div><div class="line">OK</div><div class="line"></div><div class="line">127.0.0.1:6379&gt; keys *						//才可以正常使用</div><div class="line">1) &quot;name&quot;</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# /usr/local/redis/bin/redis-cli -a flzx_3QC</div><div class="line">#在登录的同时指定密码</div><div class="line">#注意历史命令中会明文保存此密码</div><div class="line">127.0.0.1:6379&gt; keys *</div><div class="line">1) &quot;name&quot;</div></pre></td></tr></table></figure></p>
<h3 id="2、持久化"><a href="#2、持久化" class="headerlink" title="2、持久化"></a>2、持久化</h3><p>Redis 提供了不同级别的持久化方式:</p>
<p>1）RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。是默认的持久化方式。这种方式是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。这种持久化方式被称为快照 snapshotting（快照）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">save 900 1		</div><div class="line">#900秒内，最少有1个键被改动。则自动保存一次数据集</div><div class="line">save 300 10</div><div class="line">#300秒内，最少有10个键被改动。则自动保存一次数据集</div><div class="line">save 60 10000</div><div class="line">#60秒内，最少有10000个键被改动。则自动保存一次数据集</div></pre></td></tr></table></figure>
<p>实验：验证dump.rdb数据保存文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ls</div><div class="line">anaconda-ks.cfg dump.rdb  install.log  install.log .syslog</div><div class="line">#root目录下有dump.rdb文件</div><div class="line">[root@localhost ~]# /usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf</div><div class="line">#在root目录中启动redis</div><div class="line">[root@localhost ~]# /usr/local/redis/bin/redis-cli </div><div class="line">127.0.0.1:6379&gt;auth 123</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; keys *</div><div class="line">1) &quot;name2&quot;</div><div class="line">2) &quot;name&quot;</div><div class="line">3) &quot;name1&quot;</div><div class="line">#0库中有键</div><div class="line"></div><div class="line">[root@localhost ~]# cd /usr/local/redis/</div><div class="line">[root@localhostredis]# pkill -9 redis</div><div class="line">[root@localhostredis]# /usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf</div><div class="line">#在/usr/local/redis/库中重启redis</div><div class="line">[root@localhostredis]# ls</div><div class="line">[root@localhostredis]# /usr/local/redis/bin/redis-cli </div><div class="line">127.0.0.1:6379&gt; keys *</div><div class="line">(empty list or set)</div><div class="line">#0库中没有键</div><div class="line">127.0.0.1:6379&gt; save</div><div class="line">OK</div><div class="line">#保存</div><div class="line">127.0.0.1:6379&gt; quit</div><div class="line">[root@localhostredis]# ls</div><div class="line">bin  dump.rdbetc</div><div class="line">#在redis目录中也生成dump.rdb文件</div></pre></td></tr></table></figure></p>
<p>结论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# vi /usr/local/redis/etc/redis.conf</div><div class="line">dir ./</div><div class="line">#定义了dump.rdb数据库文件保存在当前位置。所以每次重启redis服务的所在位置不同，导致生成新的dump.rdb文件</div><div class="line"></div><div class="line">#将数据库保存目录写为绝对路径（注意只能是目录）</div><div class="line">dir /usr/local/redis/</div></pre></td></tr></table></figure></p>
<p>2） 使用AOF 会让你的Redis更加耐久: 你可以使用不同的持久化策略：无备份,每秒备份,每次写的时候备份。使用默认的每秒备份策略,Redis的性能依然很好(备份是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">appendonly no</div><div class="line">#默认不使用AOF持久化（450行）</div><div class="line"></div><div class="line">appendonly yes</div><div class="line">#开启AOF持久化</div><div class="line"># appendfsync always		#有写操作，就马上写入磁盘。效率最慢，最安全</div><div class="line">appendfsync everysec		#默认，每秒钟写入磁盘一次。</div><div class="line"># appendfsync no			#不进行AOF备份，将数据交给操作系统处理。最快，最不安全</div></pre></td></tr></table></figure></p>
<h3 id="3、主从备份"><a href="#3、主从备份" class="headerlink" title="3、主从备份"></a>3、主从备份</h3><p>Redis主从复制特点：</p>
<blockquote>
<p>a. Master可以拥有多个slave<br>b. 多个slave可以连接同一个master外，还可以连接到其它slave<br>c. 主从复制不会阻塞master，在同步数据时，master可以继续处理client请求<br>d. 提高系统的伸缩性</p>
</blockquote>
<p>Redis主从复制过程：</p>
<blockquote>
<p>a. Slave与master建立连接，发送sync同步命令<br>b. Master会启动一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存。<br>c. 后台完成保存后，就将此文件发送给slave<br>d. Slave将此文件保存到硬盘上</p>
</blockquote>
<p>1）    不同服务器配置主从</p>
<pre><code>A）克隆一台linux作为从服务器
克隆机需要进行如下操作：
    ①    vi /etc/sysconfig/network-scripts/ifcfg-eth0
        删除MAC地址行
    ②    rm  -rf  /etc/udev/rules.d/70-persistent-net.rules
        删除网卡和MAC地址绑定文件
    ③    注意关闭防火墙和SELinux
    ④    重启动系统


B）在从服务器上配置
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# vi /usr/local/redis/etc/redis.conf</div><div class="line"># slaveof&lt;masterip&gt;&lt;masterport&gt;</div><div class="line">#把此句开启，并指定主服务器ip和端口	（196行）</div><div class="line"></div><div class="line">masterauth flzx_3QC</div><div class="line">#设定主服务器密码</div></pre></td></tr></table></figure>
<pre><code>C）重启从服务器上redis
</code></pre><p>2） 同一台服务器实现主从配置</p>
<p>这里我们以本机配置 1台Master + 1台Slave 为例子,其中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Master IP:127.0.0.1  PORT:6379</div><div class="line">Slave1 IP:127.0.0.1  PORT:63791</div></pre></td></tr></table></figure></p>
<pre><code>A） 复制出从服务器目录
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cp -r /usr/local/redis/ /usr/local/redis-slave1</div></pre></td></tr></table></figure>
<pre><code>B） 修改redis-slave1配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# vi /usr/local/redis-slave1/etc/redis.conf</div><div class="line">pidfile /usr/local/redis-slave1/redis.pid</div><div class="line">#指定pid文件</div><div class="line">port 63791</div><div class="line">#指定端口号</div><div class="line">dir /usr/local/redis-slave1/</div><div class="line">#指定服务器目录</div><div class="line">slaveof 127.0.0.1 6379</div><div class="line">#指定主服务器IP和端口</div><div class="line">masterauth flzx_3QC</div><div class="line">#指定主服务器密码</div></pre></td></tr></table></figure>
<pre><code>C） 启动服务
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/usr/local/redis-slave1/bin/redis-server /usr/local/redis-slave1/etc/redis.conf</div><div class="line">#启动从服务器，并调用从服务器配置文件</div><div class="line"></div><div class="line">[root@localhost ~]# netstat -tlun</div><div class="line">tcp0      0 :::6379                     :::*                        LISTEN      </div><div class="line">tcp 0      0 :::63791                    :::*                        LISTEN</div><div class="line">#验证两个端口是否都启动</div></pre></td></tr></table></figure>
<pre><code>D）验证
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# /usr/local/redis/bin/redis-cli -a flzx_3QC   </div><div class="line">#启动主服务器，并建立一个键</div><div class="line">127.0.0.1:6379&gt; set bb 234</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; keys *</div><div class="line">1) &quot;sex&quot;</div><div class="line">2) &quot;aa&quot;</div><div class="line">3) &quot;name&quot;</div><div class="line">4) &quot;age&quot;</div><div class="line">5) &quot;bb&quot;</div><div class="line"></div><div class="line">[root@localhost ~]# /usr/local/redis-slave1/bin/redis-cli -a flzx_3QC -p 63791</div><div class="line">#启动从服务器，发现键已经同步</div><div class="line">127.0.0.1:63791&gt; keys *</div><div class="line">1) &quot;aa&quot;</div><div class="line">2) &quot;sex&quot;</div><div class="line">3) &quot;age&quot;</div><div class="line">4) &quot;name&quot;</div><div class="line">5) &quot;bb&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：<br>1.Redis <a href="http://redis.io/" target="_blank" rel="external">http://redis.io</a><br>2.Redis中文官方网站 <a href="http://www.redis.cn" target="_blank" rel="external">http://www.redis.cn</a><br>3.Redis 教程 | 菜鸟教程 <a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">http://www.runoob.com/redis/redis-tutorial.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、redis数据类型&quot;&gt;&lt;a href=&quot;#一、redis数据类型&quot; class=&quot;headerlink&quot; title=&quot;一、redis数据类型&quot;&gt;&lt;/a&gt;一、redis数据类型&lt;/h2&gt;&lt;h3 id=&quot;5-sorted-sets类型和操作&quot;&gt;&lt;a href=&quot;#5-sorted-sets类型和操作&quot; class=&quot;headerlink&quot; title=&quot;5. sorted sets类型和操作&quot;&gt;&lt;/a&gt;5. sorted sets类型和操作&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;sorted set是set的一个升级版本，它给集合中每个元素都定义一个分数，集合中的元素按照其分数排序。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://52fhy.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://52fhy.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>第1讲 Redis部署与基本操作</title>
    <link href="http://52fhy.github.io/2015/07/07/redis/1_Redis_deployment_and_basic_operation/"/>
    <id>http://52fhy.github.io/2015/07/07/redis/1_Redis_deployment_and_basic_operation/</id>
    <published>2015-07-07T05:04:30.000Z</published>
    <updated>2018-12-30T04:26:47.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>redis是一个key-value存储系统。<br>和Memcached类似，它支持存储的value类型相对更多，<br>包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。<br>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<a id="more"></a>
<p>在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。<br>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>Redis 是一个高性能的key-value数据库。<br>redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。<br>它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。</p>
<blockquote>
<ul>
<li>Memcache<br>内存缓存服务，缓存数据保存在内存中，一旦断电重启，数据将丢失</li>
<li>mongoDB<br>开源免费的NOSQL 数据库，提供数据持久化服务，以文档的形式提供数据组织方式，而不是表</li>
<li>Redis<br>开源免费的 NOSQL数据库，提供数据持久化服务，即能实现内存缓存服务，也能提供数据结构服务<br>取代MySQL 自建索引<br>用来弥补关系型数据的不足</li>
</ul>
</blockquote>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1、默认安装位置"><a href="#1、默认安装位置" class="headerlink" title="1、默认安装位置"></a>1、默认安装位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]#</div><div class="line">wget http://download.redis.io/releases/redis-2.8.6.tar.gz</div><div class="line">[root@localhost ~]#tar xzf redis-2.8.6.tar.gz</div><div class="line">[root@localhost ~]#cd redis-2.8.6</div><div class="line">[root@localhost ~]#make</div><div class="line">#不指定安装位置，则会把redis的可执行文件安装到  redis-2.8.6/src/目录下</div></pre></td></tr></table></figure>
<h3 id="2、指定安装位置"><a href="#2、指定安装位置" class="headerlink" title="2、指定安装位置"></a>2、指定安装位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]#tar xzf redis-2.8.6.tar.gz</div><div class="line">[root@localhost ~]# cd redis-2.8.6</div><div class="line">[root@localhost ~]# make</div><div class="line">[root@localhost ~]# make PREFIX=/usr/local/redis install</div><div class="line">#指定安装位置，如果没有指定安装位置PREFIX=/usr/local/redis，则make install会把redis安装到/usr/local/bin/目录下</div><div class="line">[root@localhost~]# mkdir/usr/local/redis/etc</div><div class="line">[root@localhost~]#cp /root/redis-2.8.6/redis.conf /usr/local/redis/etc/</div></pre></td></tr></table></figure>
<h3 id="3、安装的可执行文件的作用"><a href="#3、安装的可执行文件的作用" class="headerlink" title="3、安装的可执行文件的作用"></a>3、安装的可执行文件的作用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">redis-server	服务器端</div><div class="line">redis-cli	客户端</div><div class="line">redis-benchmark	调试</div><div class="line">redis-check-dump	数据导出</div><div class="line">redis-check-aof	数据导入</div></pre></td></tr></table></figure>
<h2 id="三、启动与关闭"><a href="#三、启动与关闭" class="headerlink" title="三、启动与关闭"></a>三、启动与关闭</h2><pre><code>1、    启动
</code></pre><p>路径/redis-server 配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/redis/bin/redis-server/usr/local/redis/etc/redis.conf</div></pre></td></tr></table></figure></p>
<p>注意：需要修改配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# vi /usr/local/redis/etc/redis.conf</div></pre></td></tr></table></figure></p>
<p>daemonizeno        改为<br>daemonize yes    #后台启动</p>
<p>端口 6379<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# /usr/local/redis/bin/redis-cli</div><div class="line"></div><div class="line">#客户端连接</div><div class="line">	-h  IP	：		连接指定的redis服务器</div><div class="line">	-p  6379：		指定redis服务器的端口</div><div class="line">	-a  密码：		使用密码登录</div><div class="line">	-n 数据库号：	指定连接哪个数据库</div></pre></td></tr></table></figure></p>
<pre><code>2、    关闭redis
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# /usr/local/redis/bin/redis-cli shutdown</div></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# pkill  -9 redis</div></pre></td></tr></table></figure></p>
<h2 id="四、配置文件"><a href="#四、配置文件" class="headerlink" title="四、配置文件"></a>四、配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div></pre></td><td class="code"><pre><div class="line">[root@localhostredis]# vi /usr/local/redis/etc/redis.conf</div><div class="line">#是否以后台进程运行，默认为no，如果需要以后台进程运行则改为yes</div><div class="line">daemonize no</div><div class="line"></div><div class="line"></div><div class="line">#如果以后台进程运行的话，就需要指定pid，你可以在此自定义redis.pid文件的位置。</div><div class="line">pidfile /var/run/redis.pid</div><div class="line"></div><div class="line"></div><div class="line">#接受连接的端口号，如果端口是0则redis将不会监听TCP socket连接</div><div class="line">port 6379</div><div class="line"></div><div class="line"># If you want you can bind a single interface, if the bind option is not</div><div class="line"># specified all the interfaces will listen for incoming connections.</div><div class="line">#</div><div class="line"># bind 127.0.0.1</div><div class="line"></div><div class="line"># Specify the path for the unix socket that will be used to listen for</div><div class="line"># incoming connections. There is no default, so Redis will not listen</div><div class="line"># on a unix socket when not specified.</div><div class="line">#</div><div class="line"># unixsocket /tmp/redis.sock</div><div class="line"># unixsocketperm 755</div><div class="line"></div><div class="line"></div><div class="line">#连接超时时间，单位秒。(0 to disable)？</div><div class="line">timeout 300000000</div><div class="line"></div><div class="line"></div><div class="line">#日志级别，默认是verbose（详细），各种日志级别：</div><div class="line">#debug:很详细的信息，适合开发和测试</div><div class="line">#verbose:包含许多不太有用的信息，但比debug要清爽一些（many rarely useful info, but not a mess like #the debug level）</div><div class="line">#notice:比较适合生产环境</div><div class="line">#warning:警告信息</div><div class="line">loglevel verbose</div><div class="line"></div><div class="line"></div><div class="line">#指定log文件的名字，默认是stdout。stdout会让redis把日志输出到标准输出。但是如果使用stdout而又以后台进#程的方式运行redis，则日志会输出到/dev/null</div><div class="line">logfilestdout</div><div class="line"></div><div class="line"></div><div class="line">#&apos;syslog-enabled&apos;设置为yes会把日志输出到系统日志，默认是no</div><div class="line"># syslog-enabled no</div><div class="line"></div><div class="line"></div><div class="line">#指定syslog的标示符，如果&apos;syslog-enabled&apos;是no，则这个选项无效。</div><div class="line"># syslog-identredis</div><div class="line"></div><div class="line"></div><div class="line">#指定syslog 设备（facility), 必须是USER或者LOCAL0到LOCAL7.</div><div class="line"># syslog-facility local0</div><div class="line"></div><div class="line"></div><div class="line">#设置数据库数目。默认的数据库是DB 0。可以通过SELECT &lt;dbid&gt;来选择一个数据库，dbid是[0,&apos;databases&apos;-1]的数字</div><div class="line">databases 16</div><div class="line"></div><div class="line">################## 快照#################################</div><div class="line">#</div><div class="line"># 硬盘上保存数据:</div><div class="line">#</div><div class="line">#   save &lt;seconds&gt;&lt;changes&gt;</div><div class="line">#</div><div class="line">#   &lt;seconds&gt;和&lt;changes&gt;都满足时就会触发数据保存动作。</div><div class="line">#   </div><div class="line">#</div><div class="line">#   以下面的例子来说明：</div><div class="line">#   过了900秒并且有1个key发生了改变 就会触发save动作</div><div class="line">#   过了300秒并且有10个key发生了改变 就会触发save动作</div><div class="line">#   过了60秒并且至少有10000个key发生了改变 也会触发save动作</div><div class="line">#</div><div class="line">#   注意：如果你不想让redis自动保存数据，那就把下面的配置注释掉！</div><div class="line"></div><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div><div class="line"></div><div class="line"></div><div class="line">#存储数据时是否压缩数据。默认是yes。</div><div class="line">rdbcompression yes</div><div class="line"></div><div class="line"># 保存dump数据的文件名</div><div class="line">dbfilenamedump.rdb</div><div class="line"></div><div class="line"># 工作目录.</div><div class="line">#</div><div class="line"># 数据会被持久化到这个目录下的‘dbfilename’指定的文件中。</div><div class="line"># </div><div class="line"># </div><div class="line"># 注意，这里指定的必须是目录而不能是文件。</div><div class="line">dir ./</div><div class="line"></div><div class="line">######## REPLICATION（复制，冗余）#################################</div><div class="line"></div><div class="line"># Master-Slave replication. 使用slaveof把一个 Redis 实例设置成为另一个Redis server的从库（热备）. 注意： #配置只对当前slave有效。</div><div class="line"># 因此可以把某个slave配置成使用不同的时间间隔来保存数据或者监听其他端口等等。</div><div class="line">#命令格式：</div><div class="line"># slaveof&lt;masterip&gt;&lt;masterport&gt;</div><div class="line"></div><div class="line"></div><div class="line">#如果master有密码保护，则在slave与master进行数据同步之前需要进行密码校验，否则master会拒绝slave的请#求。</div><div class="line">#</div><div class="line"># masterauth&lt;master-password&gt;</div><div class="line"></div><div class="line">#当slave丢失与master的连接时，或者slave仍然在于master进行数据同步时（还没有与master保持一致），#slave可以有两种方式来响应客户端请求：</div><div class="line">#</div><div class="line"># 1) 如果 slave-serve-stale-data 设置成 &apos;yes&apos; (the default) slave会仍然响应客户端请求,此时可能会有问题。</div><div class="line">#</div><div class="line"># 2) 如果 slave-serve-stale data设置成  &apos;no&apos;  slave会返回&quot;SYNC with master in progress&quot;这样的错误信息。 但 INFO 和SLAVEOF命令除外。</div><div class="line">#</div><div class="line">slave-serve-stale-data yes</div><div class="line"></div><div class="line">############### 安全 ###################################</div><div class="line"></div><div class="line"># 需要客户端在执行任何命令之前指定 AUTH &lt;PASSWORD&gt;</div><div class="line">#</div><div class="line"># requirepassfoobared</div><div class="line"></div><div class="line"># 命令重命名.</div><div class="line">#</div><div class="line">#</div><div class="line"># 例如:</div><div class="line">#</div><div class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</div><div class="line">#</div><div class="line"># 同样可以通过把一个命令重命名为空串来彻底kill掉这个命令，比如：</div><div class="line">#</div><div class="line"># rename-command CONFIG &quot;&quot;</div><div class="line"></div><div class="line">#################### 限制 ####################################</div><div class="line"></div><div class="line"># 设置最大连接数. 默认没有限制,  &apos;0&apos; 意味着不限制.</div><div class="line">#</div><div class="line"># maxclients 128</div><div class="line"></div><div class="line"></div><div class="line">#最大可使用内存。如果超过，Redis会试图删除EXPIRE集合中的keys，具体做法是：Redis会试图释放即将过期的#keys，而保护还有很长生命周期的keys。</div><div class="line">#</div><div class="line">#如果这样还不行，Redis就会报错，但像GET之类的查询请求还是会得到响应。</div><div class="line">#</div><div class="line">#警告：如果你想把Redis视为一个真正的DB的话，那不要设置&lt;maxmemory&gt;,只有你只想把Redis作为cache或者</div><div class="line">#有状态的server（&apos;state&apos; server)时才需要设置。</div><div class="line">#</div><div class="line"># maxmemory&lt;bytes&gt;</div><div class="line"></div><div class="line">#内存清理策略：如果达到了maxmemory，你可以采取如下动作：</div><div class="line"># </div><div class="line"># volatile-lru -&gt; 使用LRU算法来删除过期的set</div><div class="line"># allkeys-lru -&gt; 删除任何遵循LRU算法的key</div><div class="line"># volatile-random -&gt;随机地删除过期set中的key</div><div class="line"># allkeys-&gt;random -&gt; 随机地删除一个key</div><div class="line"># volatile-ttl -&gt; 删除最近即将过期的key（the nearest expire time (minor TTL)）</div><div class="line"># noeviction -&gt; 根本不过期，写操作直接报错</div><div class="line"># </div><div class="line">#</div><div class="line"># 默认策略:</div><div class="line">#</div><div class="line"># maxmemory-policy volatile-lru</div><div class="line"></div><div class="line"># 对于处理redis内存来说，LRU和minor TTL算法不是精确的，而是近似的（估计的）算法。所以我们会检查某些样本#来达到内存检查的目的。默认的样本数是3，你可以修改它。</div><div class="line">#</div><div class="line"># maxmemory-samples 3</div><div class="line"></div><div class="line">################# APPEND ONLY MODE ###############################</div><div class="line"></div><div class="line">#默认情况下，Redis会异步的把数据保存到硬盘。如果你的应用场景允许因为系统崩溃等极端情况而导致最新数据丢失#的话，那这种做法已经很ok了。否则你应该打开‘append only’模式，开启这种模式后，Redis会在#appendonly.aof文件中添加每一个写操作，这个文件会在Redis启动时被读取来在内存中重新构建数据集。</div><div class="line">#</div><div class="line">#注意：如果你需要，你可以同时开启‘append only’模式和异步dumps模式（你需要注释掉上面的‘save’表达式来禁#止dumps），这种情况下，Redis重建数据集时会优先使用appendonly.aof而忽略dump.rdb</div><div class="line">#</div><div class="line">appendonly no</div><div class="line"></div><div class="line">#  append only 文件名 (默认: &quot;appendonly.aof&quot;)</div><div class="line"># appendfilenameappendonly.aof</div><div class="line"></div><div class="line"># 调用fsync()函数通知操作系统立刻向硬盘写数据</div><div class="line">#</div><div class="line"># Redis支持3中模式:</div><div class="line">#</div><div class="line"># no:不fsync, 只是通知OS可以flush数据了，具体是否flush取决于OS.性能更好.</div><div class="line"># always: 每次写入append only 日志文件后都会fsync . 性能差，但很安全.</div><div class="line"># everysec: 没间隔1秒进行一次fsync. 折中.</div><div class="line">#</div><div class="line"># 默认是 &quot;everysec&quot;</div><div class="line"># appendfsync always</div><div class="line">appendfsynceverysec</div><div class="line"># appendfsync no</div><div class="line"></div><div class="line"># 当AOF fsync策略被设置为always或者everysec并且后台保存进程（saving process)正在执行大量I/O操作时</div><div class="line"># Redis可能会在fsync()调用上阻塞过长时间</div><div class="line">#</div><div class="line">no-appendfsync-on-rewrite no</div><div class="line"></div><div class="line"># append only 文件的自动重写</div><div class="line"># 当AOF 日志文件即将增长到指定百分比时，Redis可以通过调用BGREWRITEAOF 来自动重写append only文件。</div><div class="line"># </div><div class="line"># 它是这么干的：Redis会记住最近一次重写后的AOF 文件size。然后它会把这个size与当前size进行比较，如果当前# size比指定的百分比大，就会触发重写。同样，你需要指定AOF文件被重写的最小size，这对避免虽然百分比达到了# 但是实际上文件size还是很小（这种情况没有必要重写）却导致AOF文件重写的情况很有用。</div><div class="line">#</div><div class="line">#</div><div class="line"># auto-aof-rewrite-percentage 设置为 0 可以关闭AOF重写功能</div><div class="line"></div><div class="line">auto-aof-rewrite-percentage 100</div><div class="line">auto-aof-rewrite-min-size 64mb</div><div class="line"></div><div class="line">################## SLOW LOG ###################################</div><div class="line"></div><div class="line"># Redis slow log用来记录超过指定执行时间的查询。</div><div class="line"># </div><div class="line"># 你可以指定两个参数：一个是慢查询的阀值，单位是毫秒；另外一个是slow log的长度，相当于一个队列。</div><div class="line"></div><div class="line"># 负数则关闭slow log，0则会导致每个命令都被记录</div><div class="line">slowlog-log-slower-than 10000</div><div class="line"></div><div class="line"># 不设置会消耗过多内存，所以还是要设置一下。可以使用SLOWLOG RESET命令来回收slow log使用的内存</div><div class="line">slowlog-max-len 1024</div><div class="line"></div><div class="line">################ 虚拟内存 ###############################</div><div class="line">#使用redis 就别用虚拟内存了，绝对不是一个好主意，加个机器吧，所以这里不翻译啦！！</div><div class="line"></div><div class="line">###   WARNING! Virtual Memory is deprecated in Redis 2.4</div><div class="line">###   The use of Virtual Memory is strongly discouraged.</div><div class="line"></div><div class="line"># Virtual Memory allows Redis to work with datasets bigger than the actual</div><div class="line"># amount of RAM needed to hold the whole dataset in memory.</div><div class="line"># In order to do so very used keys are taken in memory while the other keys</div><div class="line"># are swapped into a swap file, similarly to what operating systems do</div><div class="line"># with memory pages.</div><div class="line">#</div><div class="line"># To enable VM just set &apos;vm-enabled&apos; to yes, and set the following three</div><div class="line"># VM parameters accordingly to your needs.</div><div class="line"></div><div class="line">vm-enabled no</div><div class="line"># vm-enabled yes</div><div class="line"></div><div class="line"># This is the path of the Redis swap file. As you can guess, swap files</div><div class="line"># can&apos;t be shared by different Redis instances, so make sure to use a swap</div><div class="line"># file for every redis process you are running. Redis will complain if the</div><div class="line"># swap file is already in use.</div><div class="line">#</div><div class="line"># The best kind of storage for the Redis swap file (that&apos;s accessed at random) </div><div class="line"># is a Solid State Disk (SSD).</div><div class="line">#</div><div class="line"># *** WARNING *** if you are using a shared hosting the default of putting</div><div class="line"># the swap file under /tmp is not secure. Create a dir with access granted</div><div class="line"># only to Redis user and configure Redis to create the swap file there.</div><div class="line">vm-swap-file /tmp/redis.swap</div><div class="line"></div><div class="line"># vm-max-memory configures the VM to use at max the specified amount of</div><div class="line"># RAM. Everything that deos not fit will be swapped on disk *if* possible, that</div><div class="line"># is, if there is still enough contiguous space in the swap file.</div><div class="line">#</div><div class="line"># With vm-max-memory 0 the system will swap everything it can. Not a good</div><div class="line"># default, just specify the max amount of RAM you can in bytes, but it&apos;s</div><div class="line"># better to leave some margin. For instance specify an amount of RAM</div><div class="line"># that&apos;s more or less between 60 and 80% of your free RAM.</div><div class="line">vm-max-memory 0</div><div class="line"></div><div class="line"># Redis swap files is split into pages. An object can be saved using multiple</div><div class="line"># contiguous pages, but pages can&apos;t be shared between different objects.</div><div class="line"># So if your page is too big, small objects swapped out on disk will waste</div><div class="line"># a lot of space. If you page is too small, there is less space in the swap</div><div class="line"># file (assuming you configured the same number of total swap file pages).</div><div class="line">#</div><div class="line"># If you use a lot of small objects, use a page size of 64 or 32 bytes.</div><div class="line"># If you use a lot of big objects, use a bigger page size.</div><div class="line"># If unsure, use the default :)</div><div class="line">vm-page-size 32</div><div class="line"></div><div class="line"># Number of total memory pages in the swap file.</div><div class="line"># Given that the page table (a bitmap of free/used pages) is taken in memory,</div><div class="line"># every 8 pages on disk will consume 1 byte of RAM.</div><div class="line">#</div><div class="line"># The total swap size is vm-page-size * vm-pages</div><div class="line">#</div><div class="line"># With the default of 32-bytes memory pages and 134217728 pages Redis will</div><div class="line"># use a 4 GB swap file, that will use 16 MB of RAM for the page table.</div><div class="line">#</div><div class="line"># It&apos;s better to use the smallest acceptable value for your application,</div><div class="line"># but the default is large in order to work in most conditions.</div><div class="line">vm-pages 134217728</div><div class="line"></div><div class="line"># Max number of VM I/O threads running at the same time.</div><div class="line"># This threads are used to read/write data from/to swap file, since they</div><div class="line"># also encode and decode objects from disk to memory or the reverse, a bigger</div><div class="line"># number of threads can help with big objects even if they can&apos;t help with</div><div class="line"># I/O itself as the physical device may not be able to couple with many</div><div class="line"># reads/writes operations at the same time.</div><div class="line">#</div><div class="line"># The special value of 0 turn off threaded I/O and enables the blocking</div><div class="line"># Virtual Memory implementation.</div><div class="line">vm-max-threads 4</div><div class="line"></div><div class="line">################高级配置###############################</div><div class="line"></div><div class="line"># Hashes are encoded in a special way (much more memory efficient) when they</div><div class="line"># have at max a given numer of elements, and the biggest element does not</div><div class="line"># exceed a given threshold. You can configure this limits with the following</div><div class="line"># configuration directives.</div><div class="line">hash-max-zipmap-entries 512</div><div class="line">hash-max-zipmap-value 64</div><div class="line"></div><div class="line"># Similarly to hashes, small lists are also encoded in a special way in order</div><div class="line"># to save a lot of space. The special representation is only used when</div><div class="line"># you are under the following limits:</div><div class="line">list-max-ziplist-entries 512</div><div class="line">list-max-ziplist-value 64</div><div class="line"></div><div class="line"># Sets have a special encoding in just one case: when a set is composed</div><div class="line"># of just strings that happens to be integers in radix 10 in the range</div><div class="line"># of 64 bit signed integers.</div><div class="line"># The following configuration setting sets the limit in the size of the</div><div class="line"># set in order to use this special memory saving encoding.</div><div class="line">set-max-intset-entries 512</div><div class="line"></div><div class="line"># Similarly to hashes and lists, sorted sets are also specially encoded in</div><div class="line"># order to save a lot of space. This encoding is only used when the length and</div><div class="line"># elements of a sorted set are below the following limits:</div><div class="line">zset-max-ziplist-entries 128</div><div class="line">zset-max-ziplist-value 64</div><div class="line"></div><div class="line"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</div><div class="line"># order to help rehashing the main Redis hash table (the one mapping top-level</div><div class="line"># keys to values). The hash table implementation redis uses (see dict.c)</div><div class="line"># performs a lazy rehashing: the more operation you run into an hash table</div><div class="line"># that is rhashing, the more rehashing &quot;steps&quot; are performed, so if the</div><div class="line"># server is idle the rehashing is never complete and some more memory is used</div><div class="line"># by the hash table.</div><div class="line"># </div><div class="line"># The default is to use this millisecond 10 times every second in order to</div><div class="line"># active rehashing the main dictionaries, freeing memory when possible.</div><div class="line">#</div><div class="line"># If unsure:</div><div class="line"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</div><div class="line"># not a good thing in your environment that Redis can reply form time to time</div><div class="line"># to queries with 2 milliseconds delay.</div><div class="line">#</div><div class="line"># use &quot;activerehashing yes&quot; if you don&apos;t have such hard requirements but</div><div class="line"># want to free memory asap when possible.</div><div class="line">activerehashing yes</div><div class="line"></div><div class="line">################## INCLUDES ###################################</div><div class="line"></div><div class="line"># Include one or more other config files here.  This is useful if you</div><div class="line"># have a standard template that goes to all redis server but also need</div><div class="line"># to customize a few per-server settings.  Include files can include</div><div class="line"># other files, so use this wisely.</div><div class="line">#</div><div class="line"># include /path/to/local.conf</div><div class="line"># include /path/to/other.conf</div></pre></td></tr></table></figure>
<h2 id="五、Redis的数据类型"><a href="#五、Redis的数据类型" class="headerlink" title="五、Redis的数据类型"></a>五、Redis的数据类型</h2><h3 id="1-共计5种类型"><a href="#1-共计5种类型" class="headerlink" title="1. 共计5种类型"></a>1. 共计5种类型</h3><pre><code>string(字符串)、hash(哈希表) list(双向队列)、set(集合)和zset(有序集合)
</code></pre><h3 id="2-String（子串类型）"><a href="#2-String（子串类型）" class="headerlink" title="2. String（子串类型）"></a>2. String（子串类型）</h3><pre><code>String是最简单的类型，一个Key对应一个Value，string类型是二进制安全的。Redis的string可以包含任何数据，比如jpg图片或者序列化的对象。
</code></pre><hr>
<p>1）set 键  “值”<br>    设置一个键和值，键存在则覆盖，返回ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set name liming</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>2）get 键<br>    获取一个键的值，返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; get name</div><div class="line">&quot;liming&quot;</div></pre></td></tr></table></figure></p>
<p>3） setnx 键 值<br>    只有当该键不存在时设置一个键的值，若键已存在则返回0表示失败（防止覆盖），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;setnx age 18</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;setnx age 18</div><div class="line">(integer) 0</div></pre></td></tr></table></figure></p>
<p>4） setex 键 [有效时间] 值<br>    设置一个指定有效期的键和值（单位秒）。不写有效时间则表示永久有效，等价于set<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;setex movie 30 canglaoshi</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;ttl movie				//获取键的有效时间</div><div class="line">(integer) 26</div><div class="line">127.0.0.1:6379&gt;ttl movie</div><div class="line">(integer) 20</div><div class="line">127.0.0.1:6379&gt; get movie</div><div class="line">&quot;canglaoshi&quot;</div><div class="line">127.0.0.1:6379&gt;ttl movie</div><div class="line">(integer) -2</div><div class="line">127.0.0.1:6379&gt; get movie</div><div class="line">(nil)</div></pre></td></tr></table></figure></p>
<p>5）ttl 键<br>    以秒为单位，返回给定 key 的剩余生存时间</p>
<pre><code>&gt;当 key 不存在时，返回 -2 。
当 key 存在但没有设置剩余生存时间时，返回 -1 。
否则，以秒为单位，返回 key 的剩余生存时间。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; ttl name</div><div class="line">(integer) -1</div></pre></td></tr></table></figure>
<p>6） setrange 键 位置 子字串<br>    替换子字符串 (替换长度由子子串长度决定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set key1 &quot;hello world&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; get key1</div><div class="line">&quot;hello world&quot;</div><div class="line">127.0.0.1:6379&gt;setrange key1 6 liming</div><div class="line">(integer) 12</div><div class="line">127.0.0.1:6379&gt; get key1</div><div class="line">&quot;hello liming&quot;</div><div class="line">	#将key1键对应值的第6个位置开始替换（字符串位置从0开始计算）</div></pre></td></tr></table></figure></p>
<p>7） mset 键1 值1 键2 值2 键3 值3 ….<br>    批量设置键和值,成功则返回ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;mset name1 lm name2 sc name3 zjj</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>8） mget 键1 键2 键3….<br>    批量获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;mget name1 name2 name3</div><div class="line">1) &quot;lm&quot;</div><div class="line">2) &quot;sc&quot;</div><div class="line">3) &quot;zjj&quot;</div></pre></td></tr></table></figure></p>
<p>9） msetnx 键1 值1 键2 值2 键3 值3 ….<br>    批量设置不存在的键和值,成功则返回ok</p>
<p>10） getset 键 新值<br>    获取原值，并设置新值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set name &quot;shenchao&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; get name</div><div class="line">&quot;shenchao&quot;</div><div class="line">127.0.0.1:6379&gt;getset name &quot;liming&quot;</div><div class="line">&quot;shenchao&quot;</div><div class="line">127.0.0.1:6379&gt; get name</div><div class="line">&quot;liming&quot;</div></pre></td></tr></table></figure></p>
<p>11） getrange 键 0 4<br>    获取指定范围的值（获取指定0到4位置上的值，字符串位置从0开始计算）。参考setrange。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;getrange key1 0 4</div><div class="line">&quot;hello&quot;</div></pre></td></tr></table></figure></p>
<p>12） incr键<br>        指定键的值做加1操作，返回加后的结果（只能加数字）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; set age 18</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;incr age</div><div class="line">(integer) 19</div><div class="line">127.0.0.1:6379&gt; get age</div><div class="line">&quot;19&quot;</div></pre></td></tr></table></figure></p>
<p>13） incrby 键 m<br>    //其中m可以是正整数或负整数<br>    加指定值，键不存在时候会设置键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;incrby age 10</div><div class="line">(integer) 29</div><div class="line">127.0.0.1:6379&gt; get age</div><div class="line">&quot;29&quot;</div><div class="line">127.0.0.1:6379&gt;incrby age -5</div><div class="line">(integer) 24</div></pre></td></tr></table></figure></p>
<p> 14）decr 键<br>    指定键的值做减1操作，返回减后的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;decr age</div><div class="line">(integer) 23</div><div class="line">127.0.0.1:6379&gt; get age</div><div class="line">&quot;23&quot;</div></pre></td></tr></table></figure></p>
<p>15） decrby 键 n<br>    //其中n可以是正整数或负整数<br>    设置某个键减上指定值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;decrby age 5</div><div class="line">(integer) 18</div><div class="line">127.0.0.1:6379&gt;decrby age -10</div><div class="line">(integer) 28</div><div class="line">127.0.0.1:6379&gt; get age</div><div class="line">&quot;28&quot;</div></pre></td></tr></table></figure></p>
<p>16）append 键 追加字串<br>    给指定key的字符串追加value，返回新字符串值的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; append name1 &quot; have a hot body!&quot;</div><div class="line">(integer) 19</div><div class="line">127.0.0.1:6379&gt; get name1</div><div class="line">&quot;lm have a hot body!&quot;</div></pre></td></tr></table></figure></p>
<p>17） strlen 键名<br>    strlen求一个键长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;strlen name1</div><div class="line">(integer) 19</div></pre></td></tr></table></figure></p>
<p>18）del命令：删除一个键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;del name3</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; get name3</div><div class="line">(nil)</div></pre></td></tr></table></figure></p>
<h3 id="3-hashs类型"><a href="#3-hashs类型" class="headerlink" title="3. hashs类型"></a>3. hashs类型</h3><pre><code>注意：redis中没有表概念，所有的数据都存入键中。
</code></pre><blockquote>
<p>string键类型：所有的值（可以是任何数据类型）都保存在一个键当中，放在一个内存块中</p>
<p>hashs键类型：所有的值也都保存在一个键当中，只是放在不同的内存块中，每个块称作字段</p>
</blockquote>
<p>1）hset key field value<br>    设置一个键，在键中保存字段和值</p>
<pre><code>hset 哈希集（键） 字段 值
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hset user1 name4 ysm</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; keys *					//查看库中所有的键</div><div class="line">1) &quot;aa&quot;</div><div class="line">2) &quot;name&quot;</div><div class="line">3) &quot;name1&quot;</div><div class="line">4) &quot;user1&quot;</div><div class="line">5) &quot;name2&quot;</div><div class="line">6) &quot;age&quot;</div><div class="line">7) &quot;key1&quot;</div></pre></td></tr></table></figure>
<p>2）hsetnx 键 字段 值<br>    设置一个键中，不存在的字段和值。如果字段存在则报错（成功返回1，失败返回0）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hsetnx user1 name1 lm</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;hsetnx user1 name1 sc</div><div class="line">(integer) 0					//报错</div><div class="line">127.0.0.1:6379&gt;hget user1 name1</div><div class="line">&quot;lm&quot;						//内容没有更新</div></pre></td></tr></table></figure></p>
<p>3）hmset  键  字段1  值1  字段2  值2 …<br>    在一个键中，批量设置字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hmset user2 name liming age 36 interest AV-Girl</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>4）hget 键 字段<br>    获取键中的一个指定字段的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hget user1 name1</div><div class="line">&quot;lm&quot;</div><div class="line">127.0.0.1:6379&gt;hget user2 interest</div><div class="line">&quot;AV-Girl&quot;</div></pre></td></tr></table></figure></p>
<p>  5）hmget 键 字段1 [字段2…]<br>    获取键中一个或多个字段的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hmget user2 name age interest</div><div class="line">1) &quot;liming&quot;</div><div class="line">2) &quot;36&quot;</div><div class="line">3) &quot;AV-Girl&quot;</div></pre></td></tr></table></figure></p>
<p>6） hexists ：判断指定的字段是否存在于键中</p>
<pre><code>hexists 键 字段
</code></pre><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HEXISTS user2 age</div><div class="line">(integer) 1							//存在</div><div class="line">127.0.0.1:6379&gt; HEXISTS user1 age	</div><div class="line">(integer) 0							//不存在</div></pre></td></tr></table></figure></p>
<p>7） hlen ：获取键中的字段数量</p>
<pre><code>hlen 键
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hlen user2</div><div class="line">(integer) 3							//user2键中有3个字段</div></pre></td></tr></table></figure>
<p>8）hkeys ：获取键中的所有字段名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hkeys user2</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;age&quot;</div><div class="line">3) &quot;interest&quot;</div></pre></td></tr></table></figure></p>
<p>9）hvals：获取键中所有字段的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hvals user2</div><div class="line">1) &quot;liming&quot;</div><div class="line">2) &quot;36&quot;</div><div class="line">3) &quot;AV-Girl&quot;</div></pre></td></tr></table></figure></p>
<p>10）hgetall ：获取键中的所有字段和值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hgetall user2</div><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;liming&quot;</div><div class="line">3) &quot;age&quot;</div><div class="line">4) &quot;36&quot;</div><div class="line">5) &quot;interest&quot;</div><div class="line">6) &quot;AV-Girl&quot;</div></pre></td></tr></table></figure></p>
<p>11）hincrby：将键中指定字段的值，增加指定的数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hincrby user2 age 5</div><div class="line">(integer) 41</div><div class="line"></div><div class="line">127.0.0.1:6379&gt; HINCRBY user2 name 5</div><div class="line">(error) ERR hash value is not an integer	//值不是数字的字段，不能加数字</div></pre></td></tr></table></figure></p>
<p>12）hdel 键 字段1 字段2<br>    删除键中的一个或多个字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;hdel user2 age interest</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt;hkeys user2</div><div class="line">1) &quot;name&quot;</div><div class="line">	//删除一个键，还是要使用del命令</div></pre></td></tr></table></figure></p>
<h3 id="4-list类型（双向链表结构）"><a href="#4-list类型（双向链表结构）" class="headerlink" title="4. list类型（双向链表结构）"></a>4. list类型（双向链表结构）</h3><blockquote>
<p>List是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key理解为链表的名字。Redis的list类型其实就是一个每个子元素都是string类型的双向链表。</p>
</blockquote>
<p>1）lpush 键 值1 [值2…]<br>    从队列左边向队列写入一个或多个值（认为队列的左面为队列头，右边为队列尾）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;lpush list1 1</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;lpush list1 2</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt;lpush list1 3</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt;lpush list1 4</div><div class="line">(integer) 4</div><div class="line"></div><div class="line">127.0.0.1:6379&gt;lpush list2 one two three four</div><div class="line">(integer) 4</div></pre></td></tr></table></figure></p>
<p>2）lrange 键 起始下标 终止下标<br>    从队列中获取指定的返回值（从队列左边向右获取）</p>
<pre><code>下标：0代表队列中第一个元素，1代表第二个元素，依次类推
    -1代表队列中最后一个元素，-2代表倒数第二个元素
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; LRANGE list1 0 -1</div><div class="line">1) &quot;4&quot;		//4是从左面写入队列的最后一个值，所以在队列的开头</div><div class="line">2) &quot;3&quot;</div><div class="line">3) &quot;2&quot;</div><div class="line">4) &quot;1&quot;		//1是从左面写入队列的第一个值，所以直接放到了队列尾。</div><div class="line">			</div><div class="line">127.0.0.1:6379&gt; LRANGE list2 0 -1</div><div class="line">1) &quot;four&quot;</div><div class="line">2) &quot;three&quot;</div><div class="line">3) &quot;two&quot;</div><div class="line">4) &quot;one&quot;</div><div class="line"></div><div class="line">127.0.0.1:6379&gt; LRANGE list1 0 1</div><div class="line">1) &quot;4&quot;</div><div class="line">2) &quot;3&quot;</div><div class="line"></div><div class="line">127.0.0.1:6379&gt; LRANGE list2 -4 3</div><div class="line">1) &quot;four&quot;		//-4代表从队列右边数第四个元素</div><div class="line">2) &quot;three&quot;</div><div class="line">3) &quot;two&quot;</div><div class="line">4) &quot;one&quot;		//3代表从队列左边数第四个元素</div></pre></td></tr></table></figure>
<p>3）rpush键 值1 [值2…]<br>    从队列右边向队列写入一个或多个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; RPUSH list3 1 2 3 4</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt; LRANGE list3 0 -1</div><div class="line">1) &quot;1&quot;		//从队列右边向队列写入值，第一个值就会写到队列的开头</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">4) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>4）linsert 键 before|after 原值 新值<br>    在队列中指定元素之前或之后插入新值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; LINSERT list3 before 3 hello</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt; LRANGE list3 0 -1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;hello&quot;</div><div class="line">4) &quot;3&quot;</div><div class="line">5) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>5）lset 键 下标 新值<br>    给队列中指定元素设定新值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;lset list3 2 &quot;5&quot;</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; LRANGE list3 0 -1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;5&quot;</div><div class="line">4) &quot;3&quot;</div><div class="line">5) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>6）lrem 键 n 指定值</p>
<pre><code>从队列中删除n个值为“指定值”的元素
n &gt; 0     从队列头向尾删除n个元素
n &lt; 0     从队列尾向头删除n个元素
n = 0    删除所有值为“指定值”的元素
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;rpush list4 hello 1 hello 2 hello 3 hello</div><div class="line">(integer) 7</div><div class="line">127.0.0.1:6379&gt;lrange list4 0 -1</div><div class="line">1) &quot;hello&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;hello&quot;</div><div class="line">4) &quot;2&quot;</div><div class="line">5) &quot;hello&quot;</div><div class="line">6) &quot;3&quot;</div><div class="line">7) &quot;hello&quot;</div><div class="line">127.0.0.1:6379&gt;lrem list4 -2 hello			//删除后两个hello</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt;lrange list4 0 -1</div><div class="line">1) &quot;hello&quot;</div><div class="line">2) &quot;1&quot;</div><div class="line">3) &quot;hello&quot;</div><div class="line">4) &quot;2&quot;</div><div class="line">5) &quot;3&quot;</div><div class="line">127.0.0.1:6379&gt;lrem list4 0 hello			//删除所有hello</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt;lrange list4 0 -1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div></pre></td></tr></table></figure>
<p>7）ltrim 键  起始下标  结束下标<br>    修剪队列，让队列只保留指定指定范围内的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; RPUSH list5 1 2 3 4</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt;ltrim list5 1 2</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt;lrange list5 0 -1</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<p>8）lpop  键<br>    从指定的队列左面移除一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;lrange list1 0 -1</div><div class="line">1) &quot;4&quot;</div><div class="line">2) &quot;3&quot;</div><div class="line">3) &quot;2&quot;</div><div class="line">4) &quot;1&quot;</div><div class="line">127.0.0.1:6379&gt;lpop list1</div><div class="line">&quot;4&quot;</div><div class="line">127.0.0.1:6379&gt;lrange list1 0 -1</div><div class="line">1) &quot;3&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;1&quot;</div></pre></td></tr></table></figure></p>
<p>9）rpop  键<br>    从指定队列的右边移除一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;lrange list1 0 -1</div><div class="line">1) &quot;3&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;1&quot;</div><div class="line">127.0.0.1:6379&gt;rpop list1</div><div class="line">&quot;1&quot;</div><div class="line">127.0.0.1:6379&gt;lrange list1 0 -1</div><div class="line">1) &quot;3&quot;</div><div class="line">2) &quot;2&quot;</div></pre></td></tr></table></figure></p>
<p>10）rpoplpush  源队列  目标队列<br>    移除源队列的最后一个元素，并把该元素写入目标队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;lrange list1 0 -1</div><div class="line">1) &quot;3&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">127.0.0.1:6379&gt;lrange list5 0 -1</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div><div class="line">127.0.0.1:6379&gt; RPOPLPUSH list1 list5</div><div class="line">&quot;2&quot;</div><div class="line">127.0.0.1:6379&gt;lrange list1 0 -1</div><div class="line">1) &quot;3&quot;</div><div class="line">127.0.0.1:6379&gt;lrange list5 0 -1</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<p>11）lindex  键  下标<br>    获取队列中指定下标元素的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;lrange list2 0 -1</div><div class="line">1) &quot;four&quot;</div><div class="line">2) &quot;three&quot;</div><div class="line">3) &quot;two&quot;</div><div class="line">4) &quot;one&quot;</div><div class="line">127.0.0.1:6379&gt;lindex list2 1 </div><div class="line">&quot;three&quot;</div><div class="line">127.0.0.1:6379&gt;lindex list2 3</div><div class="line">&quot;one&quot;</div></pre></td></tr></table></figure></p>
<p>12）llen  键<br>    获得队列的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;llen list2</div><div class="line">(integer) 4</div></pre></td></tr></table></figure></p>
<h3 id="5-sets类型和操作"><a href="#5-sets类型和操作" class="headerlink" title="5. sets类型和操作"></a>5. sets类型和操作</h3><blockquote>
<p>Set是集合，它是string类型的无序集合。对集合我们可以取并集、交集、差集。通过这些操作我们可以实现社交网站中的好友推荐和blog的tag功能。</p>
</blockquote>
<p>1） sadd  键  值1[值2…]<br>    添加一个或多个元素到集合中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sadd mset1 1</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;sadd mset1 2 3 4</div><div class="line">(integer) 3</div></pre></td></tr></table></figure></p>
<p>2） smembers  键<br>    获取集合里面所有的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;smembers mset1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">4) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>3） srem  键  值1[值2…]<br>    从集合中删除指定的一个或多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;srem mset1 3 4</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt;smembers mset1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line"></div><div class="line">	（删除键，依然使用“del 键” 命令）</div></pre></td></tr></table></figure></p>
<p>4） spop  键<br>    随机从集合中删除一个元素，并返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sadd mset2 4 5 6 7 8</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt;spop mset2</div><div class="line">&quot;4&quot;</div><div class="line">127.0.0.1:6379&gt;spop mset2</div><div class="line">&quot;5&quot;</div><div class="line">127.0.0.1:6379&gt;spop mset2</div><div class="line">&quot;8&quot;</div><div class="line">127.0.0.1:6379&gt;smembers mset2</div><div class="line">1) &quot;6&quot;</div><div class="line">2) &quot;7&quot;</div></pre></td></tr></table></figure></p>
<p>5） srandmember  键  值<br>    随机返回集合中一个元素，但不删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sadd mset3 4 5 6 7 8</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt;srandmember mset3</div><div class="line">&quot;5&quot;</div><div class="line">127.0.0.1:6379&gt;srandmember mset3</div><div class="line">&quot;5&quot;</div><div class="line">127.0.0.1:6379&gt;srandmember mset3</div><div class="line">&quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>6） scard  键<br>    获取集合里面元素个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;scard mset1</div><div class="line">(integer) 2</div></pre></td></tr></table></figure></p>
<p>7） sismember  键  值<br>    确定一个指定的值是否是集合中的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;smembers mset1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">127.0.0.1:6379&gt;sismember mset1 3</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt;sismember mset1 1</div><div class="line">(integer) 1</div></pre></td></tr></table></figure></p>
<p>8） sdiff  集合1  集合2<br>    返回集合1与集合2的差集。以集合1为主<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sadd mset4 1 2 3</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt;sadd mset5 2 3 4</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt;sdiff mset4 mset5</div><div class="line">1) &quot;1&quot;</div></pre></td></tr></table></figure></p>
<p>9） sdiffstore  新集合  集合1  集合2<br>    返回集合1和集合2的差集，并把结果存入新集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sadd mset4 1 2 3</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt;sadd mset5 2 3 4</div><div class="line">(integer) 3</div><div class="line">127.0.0.1:6379&gt;sdiffstore mset6 mset5 mset4</div><div class="line">(integer) 1				//返回值为1 ，证明成功</div><div class="line">127.0.0.1:6379&gt;smembers mset6</div><div class="line">1) &quot;4&quot;					//结果存入了mset6，值为4</div></pre></td></tr></table></figure></p>
<p>10） sinter  集合1  集合2<br>    获得两个集合的交集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;smembers mset4</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">127.0.0.1:6379&gt;smembers mset5</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div><div class="line">3) &quot;4&quot;</div><div class="line">127.0.0.1:6379&gt; sinter mset4 mset5</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<p>11） sinterstore  新集合  集合1  集合2<br>    获得集合1和集合2的交集，并把结果存入新集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sinterstore mset7 mset4 mset5</div><div class="line">(integer) 2</div><div class="line">127.0.0.1:6379&gt;smembers mset7</div><div class="line">1) &quot;2&quot;</div><div class="line">2) &quot;3&quot;</div></pre></td></tr></table></figure></p>
<p>12） sunion  集合1  集合2<br>    获得指定集合的并集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sunion mset4 mset5</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">4) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>13） sunionstore  新集合  集合1  集合2<br>    获得指定集合的并集，并把结果保存如新集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;sunionstore mset8 mset4 mset5</div><div class="line">(integer) 4</div><div class="line">127.0.0.1:6379&gt;smembers mset8</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;3&quot;</div><div class="line">4) &quot;4&quot;</div></pre></td></tr></table></figure></p>
<p>14） smove  源集合  目标集合  值<br>    将指定的值从源集合移动到目标集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt;smembers mset1</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">127.0.0.1:6379&gt;smembers mset2</div><div class="line">1) &quot;6&quot;</div><div class="line">2) &quot;7&quot;</div><div class="line">127.0.0.1:6379&gt;smove mset1 mset2 1</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt;smembers mset1</div><div class="line">1) &quot;2&quot;</div><div class="line">127.0.0.1:6379&gt;smembers mset2</div><div class="line">1) &quot;1&quot;</div><div class="line">2) &quot;6&quot;</div><div class="line">3) &quot;7&quot;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考资料：<br>1.Redis <a href="http://redis.io/" target="_blank" rel="external">http://redis.io</a><br>2.Redis中文官方网站 <a href="http://www.redis.cn" target="_blank" rel="external">http://www.redis.cn</a><br>3.Redis 教程 | 菜鸟教程 <a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">http://www.runoob.com/redis/redis-tutorial.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;redis是一个key-value存储系统。&lt;br&gt;和Memcached类似，它支持存储的value类型相对更多，&lt;br&gt;包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。&lt;br&gt;这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://52fhy.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://52fhy.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB——第三天 细说高级操作</title>
    <link href="http://52fhy.github.io/2015/07/07/mongodb/MongoDB%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E5%A4%A9%20%E7%BB%86%E8%AF%B4%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>http://52fhy.github.io/2015/07/07/mongodb/MongoDB——第三天 细说高级操作/</id>
    <published>2015-07-07T01:55:00.000Z</published>
    <updated>2015-07-07T01:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>  今天跟大家分享一下mongodb中比较好玩的知识，主要包括：聚合，游标。</p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>常见的聚合操作跟sql server一样，有：<code>count，distinct，group，mapReduce</code>。</p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>count是最简单，最容易，也是最常用的聚合工具，它的使用跟我们C#里面的count使用简直一模一样。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; db.person.count();</div><div class="line">4</div><div class="line">&gt; db.person.count(&#123;&quot;name&quot; : &quot;yjc&quot;&#125;);</div><div class="line">1</div></pre></td></tr></table></figure>
<pre><code>count()里面是条件。
</code></pre><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>这个操作相信大家也是非常熟悉的，指定了谁，谁就不能重复。</p>
<p>现在数据库里有两个name为yjc的用户，我们distinct一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; db.person.distinct(&quot;name&quot;);</div><div class="line">[ &quot;yjc&quot;, &quot;liyi&quot;, &quot;lier&quot;, &quot;yjc2&quot; ]</div></pre></td></tr></table></figure></p>
<p>distinct()里头是要指定的字符串。</p>
<h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p>在mongodb里面做group操作有点小复杂，不过大家对sql server里面的group比较熟悉的话还是一眼能看的明白的，其实group操作本质上形成了一种“k-v”模型，就像C#中的Dictionary，好，有了这种思维，我们来看看如何使用group。</p>
<p>下面举的例子就是按照age进行group操作，value为对应age的姓名。下面对这些参数介绍一下：</p>
<p><code>key</code>：  这个就是分组的key，我们这里是对年龄分组。<br><code>initial</code>: 每组都分享一个”初始化函数“，特别注意：是每一组，比如这的age=20的value的list分享一个initial函数，age=22同样也分享一个initial函数。<br><code>$reduce</code>: 这个函数的第一个参数是当前的文档对象，第二个参数是上一次function操作的累计对象，第一次为initial中的{”perosn“：[]}。有多少个文档， $reduce就会调用多少次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.person.group(&#123;</div><div class="line">	&quot;key&quot; : &#123; &quot;age&quot; : true&#125;,</div><div class="line">	&quot;initial&quot; : &#123; &quot;user&quot; : [] &#125;,</div><div class="line">	&quot;$reduce&quot; : function(cur, prev)&#123;</div><div class="line">		prev.user.push(cur.name)</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">        &#123;</div><div class="line">                &quot;age&quot; : 5,</div><div class="line">                &quot;user&quot; : [</div><div class="line">                        &quot;yjc&quot;</div><div class="line">                ]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;age&quot; : 20,</div><div class="line">                &quot;user&quot; : [</div><div class="line">                        &quot;liyi&quot;</div><div class="line">                ]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;age&quot; : 10,</div><div class="line">                &quot;user&quot; : [</div><div class="line">                        &quot;lier&quot;</div><div class="line">                ]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;age&quot; : 25,</div><div class="line">                &quot;user&quot; : [</div><div class="line">                        &quot;yjc2&quot;</div><div class="line">                ]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;age&quot; : 22,</div><div class="line">                &quot;user&quot; : [</div><div class="line">                        &quot;yjc&quot;</div><div class="line">                ]</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>看到上面的结果，是不是有点感觉，我们通过age查看到了相应的name人员，不过有时我们可能有如下的要求：</p>
<pre><code>1)想过滤掉age&gt;20一些人员。
2)有时person数组里面的人员太多，我想加上一个count属性标明一下。
</code></pre><p> 针对上面的需求，在group里面还是很好办到的，因为group有这么两个可选参数: <code>condition</code> 和 <code>finalize</code>。</p>
<p><code>condition</code>:  这个就是过滤条件。<br><code>finalize</code>: 这是个函数，每一组文档执行完后，多会触发此方法，那么在每组集合里面加上count也就是它的活了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">db.person.group(&#123;</div><div class="line">	&quot;key&quot; : &#123; &quot;age&quot; : true&#125;,</div><div class="line">	&quot;initial&quot; : &#123; &quot;user&quot; : [] &#125;,</div><div class="line">	&quot;reduce&quot; : function(cur, prev)&#123;</div><div class="line">		prev.user.push(cur.name);</div><div class="line">	&#125;,</div><div class="line">	&quot;finalize&quot; : function(prev)&#123;</div><div class="line">		prev.count = prev.user.length;</div><div class="line">	&#125;,</div><div class="line">	&quot;condition&quot; : &#123;&quot;age&quot; : &#123;$gt : 20&#125;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">        &#123;</div><div class="line">                &quot;age&quot; : 25,</div><div class="line">                &quot;user&quot; : [</div><div class="line">                        &quot;yjc2&quot;</div><div class="line">                ],</div><div class="line">                &quot;count&quot; : 1</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">                &quot;age&quot; : 22,</div><div class="line">                &quot;user&quot; : [</div><div class="line">                        &quot;yjc&quot;</div><div class="line">                ],</div><div class="line">                &quot;count&quot; : 1</div><div class="line">        &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>另外：由上面的例子，发现关键字reduce前面可以有<code>$</code>，也可以没有，但是<code>$</code>具体干嘛用的呢？</p>
<h3 id="mapReduce"><a href="#mapReduce" class="headerlink" title="mapReduce"></a>mapReduce</h3><p>这玩意算是聚合函数中最复杂的了，不过复杂也好，越复杂就越灵活。</p>
<p>mapReduce其实是一种编程模型，用在分布式计算中，其中有一个“map”函数，一个”reduce“函数。</p>
<p>  1)map：<br>    这个称为映射函数，里面会调用emit(key,value)，集合会按照你指定的key进行映射分组。</p>
<p>  2)reduce：<br>    这个称为简化函数，会对map分组后的数据进行分组简化，注意：在reduce(key,value)中的key就是<br>      emit中的key，vlaue为emit分组后的emit(value)的集合，这里也就是很多{“count”:1}的数组。</p>
<p>  3)mapReduce:<br>    这个就是最后执行的函数了，参数为map，reduce和一些可选参数。具体看程序可知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function map()&#123;</div><div class="line">	emit(this.name, &#123;count:1&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function reduce(key, value)&#123;</div><div class="line">	var result = &#123;count : 0&#125;;</div><div class="line">	for(var i=0; i&lt; value.length; i++)&#123;</div><div class="line">		result.count += value[i].count;</div><div class="line">	&#125;</div><div class="line">	return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">db.person.mapReduce(map, reduce, &#123;&quot;out&quot; : &quot;collection&quot;&#125;);</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        &quot;result&quot; : &quot;collection&quot;,</div><div class="line">        &quot;timeMillis&quot; : 93,</div><div class="line">        &quot;counts&quot; : &#123;</div><div class="line">                &quot;input&quot; : 5,</div><div class="line">                &quot;emit&quot; : 5,</div><div class="line">                &quot;reduce&quot; : 1,</div><div class="line">                &quot;output&quot; : 4</div><div class="line">        &#125;,</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从运行结我们可以看到如下信息：</p>
<p>   result: “存放的集合名“；<br>   input:传入文档的个数。<br>   emit：此函数被调用的次数。<br>   reduce：此函数被调用的次数。<br>   output:最后返回文档的个数。</p>
<p>最后我们看一下“collecton”集合里面按姓名分组的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.find();</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;_id&quot; : &quot;lier&quot;, &quot;value&quot; : &#123; &quot;count&quot; : 1 &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : &quot;liyi&quot;, &quot;value&quot; : &#123; &quot;count&quot; : 1 &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : &quot;yjc&quot;, &quot;value&quot; : &#123; &quot;count&quot; : 2 &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : &quot;yjc2&quot;, &quot;value&quot; : &#123; &quot;count&quot; : 1 &#125; &#125;</div></pre></td></tr></table></figure></p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>mongodb里面的游标有点类似我们说的C#里面延迟执行，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var list=db.person.find();</div></pre></td></tr></table></figure></p>
<p>针对这样的操作，list其实并没有获取到person中的文档，而是申明一个“查询结构”，等我们需要的时候通过for或者next()一次性加载过来，然后让游标逐行读取，当我们枚举完了之后，游标销毁，之后我们在通过list获取时，发现没有数据返回了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; var list=db.person.find();</div><div class="line">&gt; list</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;558fd39d02d9b5bcf004aaf5&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 5, &quot;address&quot; : &#123; &quot;city&quot; : &quot;beijing&quot; &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5590ac85c8e4762462ebbab2&quot;), &quot;name&quot; : &quot;liyi&quot;, &quot;age&quot; : 20, &quot;address&quot; : &#123; &quot;province&quot; : &quot;hubei&quot;, &quot;city&quot; : &quot;wuhan&quot; &#125;, &quot;favourite&quot; : [ &quot;music&quot;, &quot;movie&quot; ] &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5590adecc8e4762462ebbab3&quot;), &quot;name&quot; : &quot;lier&quot;, &quot;age&quot; : 10, &quot;adress&quot; : &#123; &quot;province&quot; : &quot;hubei&quot;, &quot;city&quot; : &quot;yichang&quot; &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5590b92aeb60c2633d9cfa24&quot;), &quot;name&quot; : &quot;yjc2&quot;, &quot;age&quot; : 25 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;55926102f431047603d95187&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 22 &#125;</div></pre></td></tr></table></figure>
<p>当然我们的“查询构造”还可以搞的复杂点，比如分页，排序都可以加进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var single=db.person.find().sort(&#123;&quot;name&quot;：1&#125;).skip(2).limit(2);</div></pre></td></tr></table></figure>
<p>那么这样的“查询构造”可以在我们需要执行的时候执行，大大提高了不必要的花销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; var single=db.person.find().sort(&#123;&quot;name&quot;:1&#125;).skip(2).limit(2);</div><div class="line">&gt; single</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;558fd39d02d9b5bcf004aaf5&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 5, &quot;address&quot; : &#123; &quot;city&quot; : &quot;beijing&quot; &#125; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;55926102f431047603d95187&quot;), &quot;name&quot; : &quot;yjc&quot;, &quot;age&quot; : 22 &#125;</div></pre></td></tr></table></figure>
<p>sort()方法来对数据进行排序，指定排序字段，并使用1或-1来指定排序方式是升序或降序。</p>
<p>skip()跳过前面两条数据。<br>limit()该函数用来指定返回结果的最大数量</p>
<blockquote>
<p>参考：<br>8天学通MongoDB——第三天 细说高级操作 - 一线码农 - 博客园<br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/02/21/2361205.html" target="_blank" rel="external">http://www.cnblogs.com/huangxincheng/archive/2012/02/21/2361205.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  今天跟大家分享一下mongodb中比较好玩的知识，主要包括：聚合，游标。&lt;/p&gt;
&lt;h2 id=&quot;聚合&quot;&gt;&lt;a href=&quot;#聚合&quot; class=&quot;headerlink&quot; title=&quot;聚合&quot;&gt;&lt;/a&gt;聚合&lt;/h2&gt;&lt;p&gt;常见的聚合操作跟sql server一样，有：&lt;code&gt;count，distinct，group，mapReduce&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;count&quot;&gt;&lt;a href=&quot;#count&quot; class=&quot;headerlink&quot; title=&quot;count&quot;&gt;&lt;/a&gt;count&lt;/h3&gt;&lt;p&gt;count是最简单，最容易，也是最常用的聚合工具，它的使用跟我们C#里面的count使用简直一模一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongo" scheme="http://52fhy.github.io/tags/mongo/"/>
    
  </entry>
  
</feed>
